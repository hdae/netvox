/**
 * Generated by orval v6.28.2 🍺
 * Do not edit manually.
 * VOICEVOX Engine
 * VOICEVOXの音声合成エンジンです。
 * OpenAPI spec version: 0.19.0
 */
import * as axios from 'axios';
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios'
import {
  useMutation,
  useQuery
} from 'react-query'
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from 'react-query'
export type SupportedDevicesSupportedDevicesGetParams = {
core_version?: string;
};

/**
 * インポートするユーザー辞書のデータ
 */
export type ImportUserDictWordsImportUserDictPostBody = {[key: string]: UserDictWord};

export type ImportUserDictWordsImportUserDictPostParams = {
/**
 * 重複したエントリがあった場合、上書きするかどうか
 */
override: boolean;
};

export type RewriteUserDictWordUserDictWordWordUuidPutParams = {
/**
 * 言葉の表層形
 */
surface: string;
/**
 * 言葉の発音（カタカナ）
 */
pronunciation: string;
/**
 * アクセント型（音が下がる場所を指す）
 */
accent_type: number;
/**
 * PROPER_NOUN（固有名詞）、COMMON_NOUN（普通名詞）、VERB（動詞）、ADJECTIVE（形容詞）、SUFFIX（語尾）のいずれか
 */
word_type?: WordTypes;
/**
 * 単語の優先度（0から10までの整数）。数字が大きいほど優先度が高くなる。1から9までの値を指定することを推奨。
 */
priority?: number;
};

export type AddUserDictWordUserDictWordPostParams = {
/**
 * 言葉の表層形
 */
surface: string;
/**
 * 言葉の発音（カタカナ）
 */
pronunciation: string;
/**
 * アクセント型（音が下がる場所を指す）
 */
accent_type: number;
/**
 * PROPER_NOUN（固有名詞）、COMMON_NOUN（普通名詞）、VERB（動詞）、ADJECTIVE（形容詞）、SUFFIX（語尾）のいずれか
 */
word_type?: WordTypes;
/**
 * 単語の優先度（0から10までの整数）。数字が大きいほど優先度が高くなる。1から9までの値を指定することを推奨
 */
priority?: number;
};

export type GetUserDictWordsUserDictGet200 = {[key: string]: UserDictWord};

export type IsInitializedSpeakerIsInitializedSpeakerGetParams = {
speaker: number;
core_version?: string;
};

export type InitializeSpeakerInitializeSpeakerPostParams = {
speaker: number;
/**
 * 既に初期化済みのスタイルの再初期化をスキップするかどうか
 */
skip_reinit?: boolean;
core_version?: string;
};

export type InstalledLibrariesInstalledLibrariesGet200 = {[key: string]: InstalledLibraryInfo};

export type SingerInfoSingerInfoGetParams = {
speaker_uuid: string;
core_version?: string;
};

export type SingersSingersGetParams = {
core_version?: string;
};

export type SpeakerInfoSpeakerInfoGetParams = {
speaker_uuid: string;
core_version?: string;
};

export type SpeakersSpeakersGetParams = {
core_version?: string;
};

export type DeletePresetDeletePresetPostParams = {
/**
 * 削除するプリセットのプリセットID
 */
id: number;
};

export type SynthesisMorphingSynthesisMorphingPostParams = {
base_speaker: number;
target_speaker: number;
morph_rate: number;
core_version?: string;
};

export type MorphableTargetsMorphableTargetsPost200Item = {[key: string]: MorphableTargetInfo};

export type MorphableTargetsMorphableTargetsPostParams = {
core_version?: string;
};

export type ValidateKanaValidateKanaPostParams = {
/**
 * 判定する対象の文字列
 */
text: string;
};

export type FrameSynthesisFrameSynthesisPostParams = {
speaker: number;
core_version?: string;
};

export type SingFrameVolumeSingFrameVolumePostParams = {
speaker: number;
core_version?: string;
};

export type SingFrameAudioQuerySingFrameAudioQueryPostParams = {
speaker: number;
core_version?: string;
};

export type MultiSynthesisMultiSynthesisPostParams = {
speaker: number;
core_version?: string;
};

export type CancellableSynthesisCancellableSynthesisPostParams = {
speaker: number;
core_version?: string;
};

export type SynthesisSynthesisPostParams = {
speaker: number;
/**
 * 疑問系のテキストが与えられたら語尾を自動調整する
 */
enable_interrogative_upspeak?: boolean;
core_version?: string;
};

export type MoraPitchMoraPitchPostParams = {
speaker: number;
core_version?: string;
};

export type MoraLengthMoraLengthPostParams = {
speaker: number;
core_version?: string;
};

export type MoraDataMoraDataPostParams = {
speaker: number;
core_version?: string;
};

export type AccentPhrasesAccentPhrasesPostParams = {
text: string;
speaker: number;
is_kana?: boolean;
core_version?: string;
};

export type AudioQueryFromPresetAudioQueryFromPresetPostParams = {
text: string;
preset_id: number;
core_version?: string;
};

export type AudioQueryAudioQueryPostParams = {
text: string;
speaker: number;
core_version?: string;
};

/**
 * 音声ライブラリの情報
 */
export interface BaseLibraryInfo {
  bytes: number;
  download_url: string;
  name: string;
  speakers: LibrarySpeaker[];
  uuid: string;
  version: string;
}

/**
 * vvlib(VOICEVOX Library)に関する情報
 */
export interface VvlibManifest {
  brand_name: string;
  engine_name: string;
  engine_uuid: string;
  manifest_version: string;
  name: string;
  uuid: string;
  version: string;
}

/**
 * fastapiでword_type引数を検証する時に使用するクラス
 */
export type WordTypes = typeof WordTypes[keyof typeof WordTypes];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const WordTypes = {
  PROPER_NOUN: 'PROPER_NOUN',
  COMMON_NOUN: 'COMMON_NOUN',
  VERB: 'VERB',
  ADJECTIVE: 'ADJECTIVE',
  SUFFIX: 'SUFFIX',
} as const;

export type ValidationErrorLocItem = string | number;

export interface ValidationError {
  loc: ValidationErrorLocItem[];
  msg: string;
  type: string;
}

/**
 * 辞書のコンパイルに使われる情報
 */
export interface UserDictWord {
  accent_associative_rule: string;
  accent_type: number;
  context_id?: number;
  inflectional_form: string;
  inflectional_type: string;
  mora_count?: number;
  part_of_speech: string;
  part_of_speech_detail_1: string;
  part_of_speech_detail_2: string;
  part_of_speech_detail_3: string;
  /**
   * @minimum 0
   * @maximum 10
   */
  priority: number;
  pronunciation: string;
  stem: string;
  surface: string;
  yomi: string;
}

/**
 * エンジンのアップデート情報
 */
export interface UpdateInfo {
  contributors?: string[];
  descriptions: string[];
  version: string;
}

/**
 * エンジンが持つ機能の一覧
 */
export interface SupportedFeatures {
  adjust_intonation_scale: boolean;
  adjust_mora_pitch: boolean;
  adjust_phoneme_length: boolean;
  adjust_pitch_scale: boolean;
  adjust_speed_scale: boolean;
  adjust_volume_scale: boolean;
  interrogative_upspeak: boolean;
  manage_library?: boolean;
  sing?: boolean;
  synthesis_morphing: boolean;
}

/**
 * 対応しているデバイスの情報
 */
export interface SupportedDevicesInfo {
  cpu: boolean;
  cuda: boolean;
  dml: boolean;
}

/**
 * スタイルの追加情報
 */
export interface StyleInfo {
  icon: string;
  id: number;
  portrait?: string;
  voice_samples: string[];
}

/**
 * An enumeration.
 */
export type SpeakerSupportPermittedSynthesisMorphing = typeof SpeakerSupportPermittedSynthesisMorphing[keyof typeof SpeakerSupportPermittedSynthesisMorphing];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SpeakerSupportPermittedSynthesisMorphing = {
  ALL: 'ALL',
  SELF_ONLY: 'SELF_ONLY',
  NOTHING: 'NOTHING',
} as const;

/**
 * 話者の対応機能の情報
 */
export interface SpeakerSupportedFeatures {
  permitted_synthesis_morphing?: SpeakerSupportPermittedSynthesisMorphing;
}

export type SpeakerStyleType = typeof SpeakerStyleType[keyof typeof SpeakerStyleType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SpeakerStyleType = {
  talk: 'talk',
  singing_teacher: 'singing_teacher',
  frame_decode: 'frame_decode',
  sing: 'sing',
} as const;

/**
 * 話者のスタイル情報
 */
export interface SpeakerStyle {
  id: number;
  name: string;
  type?: SpeakerStyleType;
}

/**
 * 話者の追加情報
 */
export interface SpeakerInfo {
  policy: string;
  portrait: string;
  style_infos: StyleInfo[];
}

/**
 * 話者情報
 */
export interface Speaker {
  name: string;
  speaker_uuid: string;
  styles: SpeakerStyle[];
  supported_features?: SpeakerSupportedFeatures;
  version?: string;
}

/**
 * 楽譜情報
 */
export interface Score {
  notes: Note[];
}

/**
 * プリセット情報
 */
export interface Preset {
  id: number;
  intonationScale: number;
  name: string;
  pitchScale: number;
  postPhonemeLength: number;
  prePhonemeLength: number;
  speaker_uuid: string;
  speedScale: number;
  style_id: number;
  volumeScale: number;
}

export type ParseKanaBadRequestErrorArgs = {[key: string]: string};

export interface ParseKanaBadRequest {
  error_args: ParseKanaBadRequestErrorArgs;
  /** |name|description|
|---|---|
| UNKNOWN_TEXT | 判別できない読み仮名があります: {text} |
| ACCENT_TOP | 句頭にアクセントは置けません: {text} |
| ACCENT_TWICE | 1つのアクセント句に二つ以上のアクセントは置けません: {text} |
| ACCENT_NOTFOUND | アクセントを指定していないアクセント句があります: {text} |
| EMPTY_PHRASE | {position}番目のアクセント句が空白です |
| INTERROGATION_MARK_NOT_AT_END | アクセント句末以外に「？」は置けません: {text} |
| INFINITE_LOOP | 処理時に無限ループになってしまいました...バグ報告をお願いします。 | */
  error_name: string;
  text: string;
}

/**
 * 音符ごとの情報
 */
export interface Note {
  frame_length: number;
  key?: number;
  lyric: string;
}

export interface MorphableTargetInfo {
  is_morphable: boolean;
}

/**
 * モーラ（子音＋母音）ごとの情報
 */
export interface Mora {
  consonant?: string;
  consonant_length?: number;
  pitch: number;
  text: string;
  vowel: string;
  vowel_length: number;
}

/**
 * 依存ライブラリのライセンス情報
 */
export interface LicenseInfo {
  license?: string;
  name: string;
  text: string;
  version?: string;
}

/**
 * 音声ライブラリに含まれる話者の情報
 */
export interface LibrarySpeaker {
  speaker: Speaker;
  speaker_info: SpeakerInfo;
}

/**
 * インストール済み音声ライブラリの情報
 */
export interface InstalledLibraryInfo {
  bytes: number;
  download_url: string;
  name: string;
  speakers: LibrarySpeaker[];
  uninstallable: boolean;
  uuid: string;
  version: string;
}

export interface HTTPValidationError {
  detail?: ValidationError[];
}

/**
 * 音素の情報
 */
export interface FramePhoneme {
  frame_length: number;
  phoneme: string;
}

/**
 * フレームごとの音声合成用のクエリ
 */
export interface FrameAudioQuery {
  f0: number[];
  outputSamplingRate: number;
  outputStereo: boolean;
  phonemes: FramePhoneme[];
  volume: number[];
  volumeScale: number;
}

/**
 * エンジン自体に関する情報
 */
export interface EngineManifest {
  brand_name: string;
  default_sampling_rate: number;
  dependency_licenses: LicenseInfo[];
  frame_rate: number;
  icon: string;
  manifest_version: string;
  name: string;
  supported_features: SupportedFeatures;
  supported_vvlib_manifest_version?: string;
  terms_of_service: string;
  update_infos: UpdateInfo[];
  url: string;
  uuid: string;
}

/**
 * ダウンロード可能な音声ライブラリの情報
 */
export interface DownloadableLibraryInfo {
  bytes: number;
  download_url: string;
  name: string;
  speakers: LibrarySpeaker[];
  uuid: string;
  version: string;
}

/**
 * CORSの許可モード
 */
export type CorsPolicyMode = typeof CorsPolicyMode[keyof typeof CorsPolicyMode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CorsPolicyMode = {
  all: 'all',
  localapps: 'localapps',
} as const;

export interface BodySingFrameVolumeSingFrameVolumePost {
  frame_audio_query: FrameAudioQuery;
  score: Score;
}

export interface BodySettingPostSettingPost {
  allow_origin?: string;
  cors_policy_mode: CorsPolicyMode;
}

/**
 * アクセント句ごとの情報
 */
export interface AccentPhrase {
  accent: number;
  is_interrogative?: boolean;
  moras: Mora[];
  pause_mora?: Mora;
}

/**
 * 音声合成用のクエリ
 */
export interface AudioQuery {
  accent_phrases: AccentPhrase[];
  intonationScale: number;
  kana?: string;
  outputSamplingRate: number;
  outputStereo: boolean;
  pitchScale: number;
  postPhonemeLength: number;
  prePhonemeLength: number;
  speedScale: number;
  volumeScale: number;
}





/**
 * 音声合成用のクエリの初期値を得ます。ここで得られたクエリはそのまま音声合成に利用できます。各値の意味は`Schemas`を参照してください。
 * @summary 音声合成用のクエリを作成する
 */
export const audioQueryAudioQueryPost = (
    params: AudioQueryAudioQueryPostParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AudioQuery>> => {
    
    return axios.default.post(
      `http://localhost:50021/audio_query`,undefined,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getAudioQueryAudioQueryPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof audioQueryAudioQueryPost>>, TError,{params: AudioQueryAudioQueryPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof audioQueryAudioQueryPost>>, TError,{params: AudioQueryAudioQueryPostParams}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof audioQueryAudioQueryPost>>, {params: AudioQueryAudioQueryPostParams}> = (props) => {
          const {params} = props ?? {};

          return  audioQueryAudioQueryPost(params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AudioQueryAudioQueryPostMutationResult = NonNullable<Awaited<ReturnType<typeof audioQueryAudioQueryPost>>>
    
    export type AudioQueryAudioQueryPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary 音声合成用のクエリを作成する
 */
export const useAudioQueryAudioQueryPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof audioQueryAudioQueryPost>>, TError,{params: AudioQueryAudioQueryPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof audioQueryAudioQueryPost>>,
        TError,
        {params: AudioQueryAudioQueryPostParams},
        TContext
      > => {

      const mutationOptions = getAudioQueryAudioQueryPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * 音声合成用のクエリの初期値を得ます。ここで得られたクエリはそのまま音声合成に利用できます。各値の意味は`Schemas`を参照してください。
 * @summary 音声合成用のクエリをプリセットを用いて作成する
 */
export const audioQueryFromPresetAudioQueryFromPresetPost = (
    params: AudioQueryFromPresetAudioQueryFromPresetPostParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AudioQuery>> => {
    
    return axios.default.post(
      `http://localhost:50021/audio_query_from_preset`,undefined,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getAudioQueryFromPresetAudioQueryFromPresetPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof audioQueryFromPresetAudioQueryFromPresetPost>>, TError,{params: AudioQueryFromPresetAudioQueryFromPresetPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof audioQueryFromPresetAudioQueryFromPresetPost>>, TError,{params: AudioQueryFromPresetAudioQueryFromPresetPostParams}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof audioQueryFromPresetAudioQueryFromPresetPost>>, {params: AudioQueryFromPresetAudioQueryFromPresetPostParams}> = (props) => {
          const {params} = props ?? {};

          return  audioQueryFromPresetAudioQueryFromPresetPost(params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AudioQueryFromPresetAudioQueryFromPresetPostMutationResult = NonNullable<Awaited<ReturnType<typeof audioQueryFromPresetAudioQueryFromPresetPost>>>
    
    export type AudioQueryFromPresetAudioQueryFromPresetPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary 音声合成用のクエリをプリセットを用いて作成する
 */
export const useAudioQueryFromPresetAudioQueryFromPresetPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof audioQueryFromPresetAudioQueryFromPresetPost>>, TError,{params: AudioQueryFromPresetAudioQueryFromPresetPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof audioQueryFromPresetAudioQueryFromPresetPost>>,
        TError,
        {params: AudioQueryFromPresetAudioQueryFromPresetPostParams},
        TContext
      > => {

      const mutationOptions = getAudioQueryFromPresetAudioQueryFromPresetPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * テキストからアクセント句を得ます。
is_kanaが`true`のとき、テキストは次のAquesTalk 風記法で解釈されます。デフォルトは`false`です。
* 全てのカナはカタカナで記述される
* アクセント句は`/`または`、`で区切る。`、`で区切った場合に限り無音区間が挿入される。
* カナの手前に`_`を入れるとそのカナは無声化される
* アクセント位置を`'`で指定する。全てのアクセント句にはアクセント位置を1つ指定する必要がある。
* アクセント句末に`？`(全角)を入れることにより疑問文の発音ができる。
 * @summary テキストからアクセント句を得る
 */
export const accentPhrasesAccentPhrasesPost = (
    params: AccentPhrasesAccentPhrasesPostParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AccentPhrase[]>> => {
    
    return axios.default.post(
      `http://localhost:50021/accent_phrases`,undefined,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getAccentPhrasesAccentPhrasesPostMutationOptions = <TError = AxiosError<ParseKanaBadRequest | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof accentPhrasesAccentPhrasesPost>>, TError,{params: AccentPhrasesAccentPhrasesPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof accentPhrasesAccentPhrasesPost>>, TError,{params: AccentPhrasesAccentPhrasesPostParams}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof accentPhrasesAccentPhrasesPost>>, {params: AccentPhrasesAccentPhrasesPostParams}> = (props) => {
          const {params} = props ?? {};

          return  accentPhrasesAccentPhrasesPost(params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AccentPhrasesAccentPhrasesPostMutationResult = NonNullable<Awaited<ReturnType<typeof accentPhrasesAccentPhrasesPost>>>
    
    export type AccentPhrasesAccentPhrasesPostMutationError = AxiosError<ParseKanaBadRequest | HTTPValidationError>

    /**
 * @summary テキストからアクセント句を得る
 */
export const useAccentPhrasesAccentPhrasesPost = <TError = AxiosError<ParseKanaBadRequest | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof accentPhrasesAccentPhrasesPost>>, TError,{params: AccentPhrasesAccentPhrasesPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof accentPhrasesAccentPhrasesPost>>,
        TError,
        {params: AccentPhrasesAccentPhrasesPostParams},
        TContext
      > => {

      const mutationOptions = getAccentPhrasesAccentPhrasesPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary アクセント句から音高・音素長を得る
 */
export const moraDataMoraDataPost = (
    accentPhrase: AccentPhrase[],
    params: MoraDataMoraDataPostParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AccentPhrase[]>> => {
    
    return axios.default.post(
      `http://localhost:50021/mora_data`,
      accentPhrase,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getMoraDataMoraDataPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof moraDataMoraDataPost>>, TError,{data: AccentPhrase[];params: MoraDataMoraDataPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof moraDataMoraDataPost>>, TError,{data: AccentPhrase[];params: MoraDataMoraDataPostParams}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof moraDataMoraDataPost>>, {data: AccentPhrase[];params: MoraDataMoraDataPostParams}> = (props) => {
          const {data,params} = props ?? {};

          return  moraDataMoraDataPost(data,params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type MoraDataMoraDataPostMutationResult = NonNullable<Awaited<ReturnType<typeof moraDataMoraDataPost>>>
    export type MoraDataMoraDataPostMutationBody = AccentPhrase[]
    export type MoraDataMoraDataPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary アクセント句から音高・音素長を得る
 */
export const useMoraDataMoraDataPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof moraDataMoraDataPost>>, TError,{data: AccentPhrase[];params: MoraDataMoraDataPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof moraDataMoraDataPost>>,
        TError,
        {data: AccentPhrase[];params: MoraDataMoraDataPostParams},
        TContext
      > => {

      const mutationOptions = getMoraDataMoraDataPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary アクセント句から音素長を得る
 */
export const moraLengthMoraLengthPost = (
    accentPhrase: AccentPhrase[],
    params: MoraLengthMoraLengthPostParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AccentPhrase[]>> => {
    
    return axios.default.post(
      `http://localhost:50021/mora_length`,
      accentPhrase,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getMoraLengthMoraLengthPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof moraLengthMoraLengthPost>>, TError,{data: AccentPhrase[];params: MoraLengthMoraLengthPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof moraLengthMoraLengthPost>>, TError,{data: AccentPhrase[];params: MoraLengthMoraLengthPostParams}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof moraLengthMoraLengthPost>>, {data: AccentPhrase[];params: MoraLengthMoraLengthPostParams}> = (props) => {
          const {data,params} = props ?? {};

          return  moraLengthMoraLengthPost(data,params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type MoraLengthMoraLengthPostMutationResult = NonNullable<Awaited<ReturnType<typeof moraLengthMoraLengthPost>>>
    export type MoraLengthMoraLengthPostMutationBody = AccentPhrase[]
    export type MoraLengthMoraLengthPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary アクセント句から音素長を得る
 */
export const useMoraLengthMoraLengthPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof moraLengthMoraLengthPost>>, TError,{data: AccentPhrase[];params: MoraLengthMoraLengthPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof moraLengthMoraLengthPost>>,
        TError,
        {data: AccentPhrase[];params: MoraLengthMoraLengthPostParams},
        TContext
      > => {

      const mutationOptions = getMoraLengthMoraLengthPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary アクセント句から音高を得る
 */
export const moraPitchMoraPitchPost = (
    accentPhrase: AccentPhrase[],
    params: MoraPitchMoraPitchPostParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AccentPhrase[]>> => {
    
    return axios.default.post(
      `http://localhost:50021/mora_pitch`,
      accentPhrase,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getMoraPitchMoraPitchPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof moraPitchMoraPitchPost>>, TError,{data: AccentPhrase[];params: MoraPitchMoraPitchPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof moraPitchMoraPitchPost>>, TError,{data: AccentPhrase[];params: MoraPitchMoraPitchPostParams}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof moraPitchMoraPitchPost>>, {data: AccentPhrase[];params: MoraPitchMoraPitchPostParams}> = (props) => {
          const {data,params} = props ?? {};

          return  moraPitchMoraPitchPost(data,params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type MoraPitchMoraPitchPostMutationResult = NonNullable<Awaited<ReturnType<typeof moraPitchMoraPitchPost>>>
    export type MoraPitchMoraPitchPostMutationBody = AccentPhrase[]
    export type MoraPitchMoraPitchPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary アクセント句から音高を得る
 */
export const useMoraPitchMoraPitchPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof moraPitchMoraPitchPost>>, TError,{data: AccentPhrase[];params: MoraPitchMoraPitchPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof moraPitchMoraPitchPost>>,
        TError,
        {data: AccentPhrase[];params: MoraPitchMoraPitchPostParams},
        TContext
      > => {

      const mutationOptions = getMoraPitchMoraPitchPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 音声合成する
 */
export const synthesisSynthesisPost = (
    audioQuery: AudioQuery,
    params: SynthesisSynthesisPostParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Blob>> => {
    
    return axios.default.post(
      `http://localhost:50021/synthesis`,
      audioQuery,{
        responseType: 'blob',
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getSynthesisSynthesisPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof synthesisSynthesisPost>>, TError,{data: AudioQuery;params: SynthesisSynthesisPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof synthesisSynthesisPost>>, TError,{data: AudioQuery;params: SynthesisSynthesisPostParams}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof synthesisSynthesisPost>>, {data: AudioQuery;params: SynthesisSynthesisPostParams}> = (props) => {
          const {data,params} = props ?? {};

          return  synthesisSynthesisPost(data,params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SynthesisSynthesisPostMutationResult = NonNullable<Awaited<ReturnType<typeof synthesisSynthesisPost>>>
    export type SynthesisSynthesisPostMutationBody = AudioQuery
    export type SynthesisSynthesisPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary 音声合成する
 */
export const useSynthesisSynthesisPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof synthesisSynthesisPost>>, TError,{data: AudioQuery;params: SynthesisSynthesisPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof synthesisSynthesisPost>>,
        TError,
        {data: AudioQuery;params: SynthesisSynthesisPostParams},
        TContext
      > => {

      const mutationOptions = getSynthesisSynthesisPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 音声合成する（キャンセル可能）
 */
export const cancellableSynthesisCancellableSynthesisPost = (
    audioQuery: AudioQuery,
    params: CancellableSynthesisCancellableSynthesisPostParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Blob>> => {
    
    return axios.default.post(
      `http://localhost:50021/cancellable_synthesis`,
      audioQuery,{
        responseType: 'blob',
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getCancellableSynthesisCancellableSynthesisPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cancellableSynthesisCancellableSynthesisPost>>, TError,{data: AudioQuery;params: CancellableSynthesisCancellableSynthesisPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof cancellableSynthesisCancellableSynthesisPost>>, TError,{data: AudioQuery;params: CancellableSynthesisCancellableSynthesisPostParams}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof cancellableSynthesisCancellableSynthesisPost>>, {data: AudioQuery;params: CancellableSynthesisCancellableSynthesisPostParams}> = (props) => {
          const {data,params} = props ?? {};

          return  cancellableSynthesisCancellableSynthesisPost(data,params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CancellableSynthesisCancellableSynthesisPostMutationResult = NonNullable<Awaited<ReturnType<typeof cancellableSynthesisCancellableSynthesisPost>>>
    export type CancellableSynthesisCancellableSynthesisPostMutationBody = AudioQuery
    export type CancellableSynthesisCancellableSynthesisPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary 音声合成する（キャンセル可能）
 */
export const useCancellableSynthesisCancellableSynthesisPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cancellableSynthesisCancellableSynthesisPost>>, TError,{data: AudioQuery;params: CancellableSynthesisCancellableSynthesisPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof cancellableSynthesisCancellableSynthesisPost>>,
        TError,
        {data: AudioQuery;params: CancellableSynthesisCancellableSynthesisPostParams},
        TContext
      > => {

      const mutationOptions = getCancellableSynthesisCancellableSynthesisPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary 複数まとめて音声合成する
 */
export const multiSynthesisMultiSynthesisPost = (
    audioQuery: AudioQuery[],
    params: MultiSynthesisMultiSynthesisPostParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Blob>> => {
    
    return axios.default.post(
      `http://localhost:50021/multi_synthesis`,
      audioQuery,{
        responseType: 'blob',
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getMultiSynthesisMultiSynthesisPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof multiSynthesisMultiSynthesisPost>>, TError,{data: AudioQuery[];params: MultiSynthesisMultiSynthesisPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof multiSynthesisMultiSynthesisPost>>, TError,{data: AudioQuery[];params: MultiSynthesisMultiSynthesisPostParams}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof multiSynthesisMultiSynthesisPost>>, {data: AudioQuery[];params: MultiSynthesisMultiSynthesisPostParams}> = (props) => {
          const {data,params} = props ?? {};

          return  multiSynthesisMultiSynthesisPost(data,params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type MultiSynthesisMultiSynthesisPostMutationResult = NonNullable<Awaited<ReturnType<typeof multiSynthesisMultiSynthesisPost>>>
    export type MultiSynthesisMultiSynthesisPostMutationBody = AudioQuery[]
    export type MultiSynthesisMultiSynthesisPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary 複数まとめて音声合成する
 */
export const useMultiSynthesisMultiSynthesisPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof multiSynthesisMultiSynthesisPost>>, TError,{data: AudioQuery[];params: MultiSynthesisMultiSynthesisPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof multiSynthesisMultiSynthesisPost>>,
        TError,
        {data: AudioQuery[];params: MultiSynthesisMultiSynthesisPostParams},
        TContext
      > => {

      const mutationOptions = getMultiSynthesisMultiSynthesisPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * 歌唱音声合成用のクエリの初期値を得ます。ここで得られたクエリはそのまま歌唱音声合成に利用できます。各値の意味は`Schemas`を参照してください。
 * @summary 歌唱音声合成用のクエリを作成する
 */
export const singFrameAudioQuerySingFrameAudioQueryPost = (
    score: Score,
    params: SingFrameAudioQuerySingFrameAudioQueryPostParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<FrameAudioQuery>> => {
    
    return axios.default.post(
      `http://localhost:50021/sing_frame_audio_query`,
      score,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getSingFrameAudioQuerySingFrameAudioQueryPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof singFrameAudioQuerySingFrameAudioQueryPost>>, TError,{data: Score;params: SingFrameAudioQuerySingFrameAudioQueryPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof singFrameAudioQuerySingFrameAudioQueryPost>>, TError,{data: Score;params: SingFrameAudioQuerySingFrameAudioQueryPostParams}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof singFrameAudioQuerySingFrameAudioQueryPost>>, {data: Score;params: SingFrameAudioQuerySingFrameAudioQueryPostParams}> = (props) => {
          const {data,params} = props ?? {};

          return  singFrameAudioQuerySingFrameAudioQueryPost(data,params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SingFrameAudioQuerySingFrameAudioQueryPostMutationResult = NonNullable<Awaited<ReturnType<typeof singFrameAudioQuerySingFrameAudioQueryPost>>>
    export type SingFrameAudioQuerySingFrameAudioQueryPostMutationBody = Score
    export type SingFrameAudioQuerySingFrameAudioQueryPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary 歌唱音声合成用のクエリを作成する
 */
export const useSingFrameAudioQuerySingFrameAudioQueryPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof singFrameAudioQuerySingFrameAudioQueryPost>>, TError,{data: Score;params: SingFrameAudioQuerySingFrameAudioQueryPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof singFrameAudioQuerySingFrameAudioQueryPost>>,
        TError,
        {data: Score;params: SingFrameAudioQuerySingFrameAudioQueryPostParams},
        TContext
      > => {

      const mutationOptions = getSingFrameAudioQuerySingFrameAudioQueryPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary スコア・歌唱音声合成用のクエリからフレームごとの音量を得る
 */
export const singFrameVolumeSingFrameVolumePost = (
    bodySingFrameVolumeSingFrameVolumePost: BodySingFrameVolumeSingFrameVolumePost,
    params: SingFrameVolumeSingFrameVolumePostParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<number[]>> => {
    
    return axios.default.post(
      `http://localhost:50021/sing_frame_volume`,
      bodySingFrameVolumeSingFrameVolumePost,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getSingFrameVolumeSingFrameVolumePostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof singFrameVolumeSingFrameVolumePost>>, TError,{data: BodySingFrameVolumeSingFrameVolumePost;params: SingFrameVolumeSingFrameVolumePostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof singFrameVolumeSingFrameVolumePost>>, TError,{data: BodySingFrameVolumeSingFrameVolumePost;params: SingFrameVolumeSingFrameVolumePostParams}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof singFrameVolumeSingFrameVolumePost>>, {data: BodySingFrameVolumeSingFrameVolumePost;params: SingFrameVolumeSingFrameVolumePostParams}> = (props) => {
          const {data,params} = props ?? {};

          return  singFrameVolumeSingFrameVolumePost(data,params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SingFrameVolumeSingFrameVolumePostMutationResult = NonNullable<Awaited<ReturnType<typeof singFrameVolumeSingFrameVolumePost>>>
    export type SingFrameVolumeSingFrameVolumePostMutationBody = BodySingFrameVolumeSingFrameVolumePost
    export type SingFrameVolumeSingFrameVolumePostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary スコア・歌唱音声合成用のクエリからフレームごとの音量を得る
 */
export const useSingFrameVolumeSingFrameVolumePost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof singFrameVolumeSingFrameVolumePost>>, TError,{data: BodySingFrameVolumeSingFrameVolumePost;params: SingFrameVolumeSingFrameVolumePostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof singFrameVolumeSingFrameVolumePost>>,
        TError,
        {data: BodySingFrameVolumeSingFrameVolumePost;params: SingFrameVolumeSingFrameVolumePostParams},
        TContext
      > => {

      const mutationOptions = getSingFrameVolumeSingFrameVolumePostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * 歌唱音声合成を行います。
 * @summary Frame Synthesis
 */
export const frameSynthesisFrameSynthesisPost = (
    frameAudioQuery: FrameAudioQuery,
    params: FrameSynthesisFrameSynthesisPostParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Blob>> => {
    
    return axios.default.post(
      `http://localhost:50021/frame_synthesis`,
      frameAudioQuery,{
        responseType: 'blob',
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getFrameSynthesisFrameSynthesisPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof frameSynthesisFrameSynthesisPost>>, TError,{data: FrameAudioQuery;params: FrameSynthesisFrameSynthesisPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof frameSynthesisFrameSynthesisPost>>, TError,{data: FrameAudioQuery;params: FrameSynthesisFrameSynthesisPostParams}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof frameSynthesisFrameSynthesisPost>>, {data: FrameAudioQuery;params: FrameSynthesisFrameSynthesisPostParams}> = (props) => {
          const {data,params} = props ?? {};

          return  frameSynthesisFrameSynthesisPost(data,params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type FrameSynthesisFrameSynthesisPostMutationResult = NonNullable<Awaited<ReturnType<typeof frameSynthesisFrameSynthesisPost>>>
    export type FrameSynthesisFrameSynthesisPostMutationBody = FrameAudioQuery
    export type FrameSynthesisFrameSynthesisPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Frame Synthesis
 */
export const useFrameSynthesisFrameSynthesisPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof frameSynthesisFrameSynthesisPost>>, TError,{data: FrameAudioQuery;params: FrameSynthesisFrameSynthesisPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof frameSynthesisFrameSynthesisPost>>,
        TError,
        {data: FrameAudioQuery;params: FrameSynthesisFrameSynthesisPostParams},
        TContext
      > => {

      const mutationOptions = getFrameSynthesisFrameSynthesisPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * base64エンコードされたwavデータを一纏めにし、wavファイルで返します。
 * @summary base64エンコードされた複数のwavデータを一つに結合する
 */
export const connectWavesConnectWavesPost = (
    connectWavesConnectWavesPostBody: string[], options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Blob>> => {
    
    return axios.default.post(
      `http://localhost:50021/connect_waves`,
      connectWavesConnectWavesPostBody,{
        responseType: 'blob',
    ...options,}
    );
  }



export const getConnectWavesConnectWavesPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof connectWavesConnectWavesPost>>, TError,{data: string[]}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof connectWavesConnectWavesPost>>, TError,{data: string[]}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof connectWavesConnectWavesPost>>, {data: string[]}> = (props) => {
          const {data} = props ?? {};

          return  connectWavesConnectWavesPost(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ConnectWavesConnectWavesPostMutationResult = NonNullable<Awaited<ReturnType<typeof connectWavesConnectWavesPost>>>
    export type ConnectWavesConnectWavesPostMutationBody = string[]
    export type ConnectWavesConnectWavesPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary base64エンコードされた複数のwavデータを一つに結合する
 */
export const useConnectWavesConnectWavesPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof connectWavesConnectWavesPost>>, TError,{data: string[]}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof connectWavesConnectWavesPost>>,
        TError,
        {data: string[]},
        TContext
      > => {

      const mutationOptions = getConnectWavesConnectWavesPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * テキストがAquesTalk 風記法に従っているかどうかを判定します。
従っていない場合はエラーが返ります。
 * @summary テキストがAquesTalk 風記法に従っているか判定する
 */
export const validateKanaValidateKanaPost = (
    params: ValidateKanaValidateKanaPostParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<boolean>> => {
    
    return axios.default.post(
      `http://localhost:50021/validate_kana`,undefined,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getValidateKanaValidateKanaPostMutationOptions = <TError = AxiosError<ParseKanaBadRequest | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof validateKanaValidateKanaPost>>, TError,{params: ValidateKanaValidateKanaPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof validateKanaValidateKanaPost>>, TError,{params: ValidateKanaValidateKanaPostParams}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof validateKanaValidateKanaPost>>, {params: ValidateKanaValidateKanaPostParams}> = (props) => {
          const {params} = props ?? {};

          return  validateKanaValidateKanaPost(params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ValidateKanaValidateKanaPostMutationResult = NonNullable<Awaited<ReturnType<typeof validateKanaValidateKanaPost>>>
    
    export type ValidateKanaValidateKanaPostMutationError = AxiosError<ParseKanaBadRequest | HTTPValidationError>

    /**
 * @summary テキストがAquesTalk 風記法に従っているか判定する
 */
export const useValidateKanaValidateKanaPost = <TError = AxiosError<ParseKanaBadRequest | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof validateKanaValidateKanaPost>>, TError,{params: ValidateKanaValidateKanaPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof validateKanaValidateKanaPost>>,
        TError,
        {params: ValidateKanaValidateKanaPostParams},
        TContext
      > => {

      const mutationOptions = getValidateKanaValidateKanaPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * 指定されたベーススタイルに対してエンジン内の各話者がモーフィング機能を利用可能か返します。
モーフィングの許可/禁止は`/speakers`の`speaker.supported_features.synthesis_morphing`に記載されています。
プロパティが存在しない場合は、モーフィングが許可されているとみなします。
返り値のスタイルIDはstring型なので注意。
 * @summary 指定したスタイルに対してエンジン内の話者がモーフィングが可能か判定する
 */
export const morphableTargetsMorphableTargetsPost = (
    morphableTargetsMorphableTargetsPostBody: number[],
    params?: MorphableTargetsMorphableTargetsPostParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MorphableTargetsMorphableTargetsPost200Item[]>> => {
    
    return axios.default.post(
      `http://localhost:50021/morphable_targets`,
      morphableTargetsMorphableTargetsPostBody,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getMorphableTargetsMorphableTargetsPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof morphableTargetsMorphableTargetsPost>>, TError,{data: number[];params?: MorphableTargetsMorphableTargetsPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof morphableTargetsMorphableTargetsPost>>, TError,{data: number[];params?: MorphableTargetsMorphableTargetsPostParams}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof morphableTargetsMorphableTargetsPost>>, {data: number[];params?: MorphableTargetsMorphableTargetsPostParams}> = (props) => {
          const {data,params} = props ?? {};

          return  morphableTargetsMorphableTargetsPost(data,params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type MorphableTargetsMorphableTargetsPostMutationResult = NonNullable<Awaited<ReturnType<typeof morphableTargetsMorphableTargetsPost>>>
    export type MorphableTargetsMorphableTargetsPostMutationBody = number[]
    export type MorphableTargetsMorphableTargetsPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary 指定したスタイルに対してエンジン内の話者がモーフィングが可能か判定する
 */
export const useMorphableTargetsMorphableTargetsPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof morphableTargetsMorphableTargetsPost>>, TError,{data: number[];params?: MorphableTargetsMorphableTargetsPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof morphableTargetsMorphableTargetsPost>>,
        TError,
        {data: number[];params?: MorphableTargetsMorphableTargetsPostParams},
        TContext
      > => {

      const mutationOptions = getMorphableTargetsMorphableTargetsPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * 指定された2種類のスタイルで音声を合成、指定した割合でモーフィングした音声を得ます。
モーフィングの割合は`morph_rate`で指定でき、0.0でベースのスタイル、1.0でターゲットのスタイルに近づきます。
 * @summary 2種類のスタイルでモーフィングした音声を合成する
 */
export const synthesisMorphingSynthesisMorphingPost = (
    audioQuery: AudioQuery,
    params: SynthesisMorphingSynthesisMorphingPostParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Blob>> => {
    
    return axios.default.post(
      `http://localhost:50021/synthesis_morphing`,
      audioQuery,{
        responseType: 'blob',
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getSynthesisMorphingSynthesisMorphingPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof synthesisMorphingSynthesisMorphingPost>>, TError,{data: AudioQuery;params: SynthesisMorphingSynthesisMorphingPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof synthesisMorphingSynthesisMorphingPost>>, TError,{data: AudioQuery;params: SynthesisMorphingSynthesisMorphingPostParams}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof synthesisMorphingSynthesisMorphingPost>>, {data: AudioQuery;params: SynthesisMorphingSynthesisMorphingPostParams}> = (props) => {
          const {data,params} = props ?? {};

          return  synthesisMorphingSynthesisMorphingPost(data,params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SynthesisMorphingSynthesisMorphingPostMutationResult = NonNullable<Awaited<ReturnType<typeof synthesisMorphingSynthesisMorphingPost>>>
    export type SynthesisMorphingSynthesisMorphingPostMutationBody = AudioQuery
    export type SynthesisMorphingSynthesisMorphingPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary 2種類のスタイルでモーフィングした音声を合成する
 */
export const useSynthesisMorphingSynthesisMorphingPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof synthesisMorphingSynthesisMorphingPost>>, TError,{data: AudioQuery;params: SynthesisMorphingSynthesisMorphingPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof synthesisMorphingSynthesisMorphingPost>>,
        TError,
        {data: AudioQuery;params: SynthesisMorphingSynthesisMorphingPostParams},
        TContext
      > => {

      const mutationOptions = getSynthesisMorphingSynthesisMorphingPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * エンジンが保持しているプリセットの設定を返します
 * @summary Get Presets
 */
export const getPresetsPresetsGet = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Preset[]>> => {
    
    return axios.default.get(
      `http://localhost:50021/presets`,options
    );
  }


export const getGetPresetsPresetsGetQueryKey = () => {
    return [`http://localhost:50021/presets`] as const;
    }

    
export const getGetPresetsPresetsGetQueryOptions = <TData = Awaited<ReturnType<typeof getPresetsPresetsGet>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getPresetsPresetsGet>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPresetsPresetsGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPresetsPresetsGet>>> = ({ signal }) => getPresetsPresetsGet({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPresetsPresetsGet>>, TError, TData> & { queryKey: QueryKey }
}

export type GetPresetsPresetsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getPresetsPresetsGet>>>
export type GetPresetsPresetsGetQueryError = AxiosError<unknown>

/**
 * @summary Get Presets
 */
export const useGetPresetsPresetsGet = <TData = Awaited<ReturnType<typeof getPresetsPresetsGet>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getPresetsPresetsGet>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetPresetsPresetsGetQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 新しいプリセットを追加します
 * @summary Add Preset
 */
export const addPresetAddPresetPost = (
    preset: Preset, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<number>> => {
    
    return axios.default.post(
      `http://localhost:50021/add_preset`,
      preset,options
    );
  }



export const getAddPresetAddPresetPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addPresetAddPresetPost>>, TError,{data: Preset}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof addPresetAddPresetPost>>, TError,{data: Preset}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addPresetAddPresetPost>>, {data: Preset}> = (props) => {
          const {data} = props ?? {};

          return  addPresetAddPresetPost(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddPresetAddPresetPostMutationResult = NonNullable<Awaited<ReturnType<typeof addPresetAddPresetPost>>>
    export type AddPresetAddPresetPostMutationBody = Preset
    export type AddPresetAddPresetPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Add Preset
 */
export const useAddPresetAddPresetPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addPresetAddPresetPost>>, TError,{data: Preset}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof addPresetAddPresetPost>>,
        TError,
        {data: Preset},
        TContext
      > => {

      const mutationOptions = getAddPresetAddPresetPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * 既存のプリセットを更新します
 * @summary Update Preset
 */
export const updatePresetUpdatePresetPost = (
    preset: Preset, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<number>> => {
    
    return axios.default.post(
      `http://localhost:50021/update_preset`,
      preset,options
    );
  }



export const getUpdatePresetUpdatePresetPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePresetUpdatePresetPost>>, TError,{data: Preset}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updatePresetUpdatePresetPost>>, TError,{data: Preset}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatePresetUpdatePresetPost>>, {data: Preset}> = (props) => {
          const {data} = props ?? {};

          return  updatePresetUpdatePresetPost(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdatePresetUpdatePresetPostMutationResult = NonNullable<Awaited<ReturnType<typeof updatePresetUpdatePresetPost>>>
    export type UpdatePresetUpdatePresetPostMutationBody = Preset
    export type UpdatePresetUpdatePresetPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Update Preset
 */
export const useUpdatePresetUpdatePresetPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePresetUpdatePresetPost>>, TError,{data: Preset}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof updatePresetUpdatePresetPost>>,
        TError,
        {data: Preset},
        TContext
      > => {

      const mutationOptions = getUpdatePresetUpdatePresetPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * 既存のプリセットを削除します
 * @summary Delete Preset
 */
export const deletePresetDeletePresetPost = (
    params: DeletePresetDeletePresetPostParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.default.post(
      `http://localhost:50021/delete_preset`,undefined,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getDeletePresetDeletePresetPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePresetDeletePresetPost>>, TError,{params: DeletePresetDeletePresetPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deletePresetDeletePresetPost>>, TError,{params: DeletePresetDeletePresetPostParams}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePresetDeletePresetPost>>, {params: DeletePresetDeletePresetPostParams}> = (props) => {
          const {params} = props ?? {};

          return  deletePresetDeletePresetPost(params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeletePresetDeletePresetPostMutationResult = NonNullable<Awaited<ReturnType<typeof deletePresetDeletePresetPost>>>
    
    export type DeletePresetDeletePresetPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Delete Preset
 */
export const useDeletePresetDeletePresetPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePresetDeletePresetPost>>, TError,{params: DeletePresetDeletePresetPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deletePresetDeletePresetPost>>,
        TError,
        {params: DeletePresetDeletePresetPostParams},
        TContext
      > => {

      const mutationOptions = getDeletePresetDeletePresetPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Version
 */
export const versionVersionGet = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    
    return axios.default.get(
      `http://localhost:50021/version`,options
    );
  }


export const getVersionVersionGetQueryKey = () => {
    return [`http://localhost:50021/version`] as const;
    }

    
export const getVersionVersionGetQueryOptions = <TData = Awaited<ReturnType<typeof versionVersionGet>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof versionVersionGet>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getVersionVersionGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof versionVersionGet>>> = ({ signal }) => versionVersionGet({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof versionVersionGet>>, TError, TData> & { queryKey: QueryKey }
}

export type VersionVersionGetQueryResult = NonNullable<Awaited<ReturnType<typeof versionVersionGet>>>
export type VersionVersionGetQueryError = AxiosError<unknown>

/**
 * @summary Version
 */
export const useVersionVersionGet = <TData = Awaited<ReturnType<typeof versionVersionGet>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof versionVersionGet>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getVersionVersionGetQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Core Versions
 */
export const coreVersionsCoreVersionsGet = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string[]>> => {
    
    return axios.default.get(
      `http://localhost:50021/core_versions`,options
    );
  }


export const getCoreVersionsCoreVersionsGetQueryKey = () => {
    return [`http://localhost:50021/core_versions`] as const;
    }

    
export const getCoreVersionsCoreVersionsGetQueryOptions = <TData = Awaited<ReturnType<typeof coreVersionsCoreVersionsGet>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof coreVersionsCoreVersionsGet>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCoreVersionsCoreVersionsGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof coreVersionsCoreVersionsGet>>> = ({ signal }) => coreVersionsCoreVersionsGet({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof coreVersionsCoreVersionsGet>>, TError, TData> & { queryKey: QueryKey }
}

export type CoreVersionsCoreVersionsGetQueryResult = NonNullable<Awaited<ReturnType<typeof coreVersionsCoreVersionsGet>>>
export type CoreVersionsCoreVersionsGetQueryError = AxiosError<unknown>

/**
 * @summary Core Versions
 */
export const useCoreVersionsCoreVersionsGet = <TData = Awaited<ReturnType<typeof coreVersionsCoreVersionsGet>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof coreVersionsCoreVersionsGet>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getCoreVersionsCoreVersionsGetQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Speakers
 */
export const speakersSpeakersGet = (
    params?: SpeakersSpeakersGetParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Speaker[]>> => {
    
    return axios.default.get(
      `http://localhost:50021/speakers`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getSpeakersSpeakersGetQueryKey = (params?: SpeakersSpeakersGetParams,) => {
    return [`http://localhost:50021/speakers`, ...(params ? [params]: [])] as const;
    }

    
export const getSpeakersSpeakersGetQueryOptions = <TData = Awaited<ReturnType<typeof speakersSpeakersGet>>, TError = AxiosError<HTTPValidationError>>(params?: SpeakersSpeakersGetParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof speakersSpeakersGet>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSpeakersSpeakersGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof speakersSpeakersGet>>> = ({ signal }) => speakersSpeakersGet(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof speakersSpeakersGet>>, TError, TData> & { queryKey: QueryKey }
}

export type SpeakersSpeakersGetQueryResult = NonNullable<Awaited<ReturnType<typeof speakersSpeakersGet>>>
export type SpeakersSpeakersGetQueryError = AxiosError<HTTPValidationError>

/**
 * @summary Speakers
 */
export const useSpeakersSpeakersGet = <TData = Awaited<ReturnType<typeof speakersSpeakersGet>>, TError = AxiosError<HTTPValidationError>>(
 params?: SpeakersSpeakersGetParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof speakersSpeakersGet>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getSpeakersSpeakersGetQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 指定されたspeaker_uuidに関する情報をjson形式で返します。
画像や音声はbase64エンコードされたものが返されます。
 * @summary Speaker Info
 */
export const speakerInfoSpeakerInfoGet = (
    params: SpeakerInfoSpeakerInfoGetParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SpeakerInfo>> => {
    
    return axios.default.get(
      `http://localhost:50021/speaker_info`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getSpeakerInfoSpeakerInfoGetQueryKey = (params: SpeakerInfoSpeakerInfoGetParams,) => {
    return [`http://localhost:50021/speaker_info`, ...(params ? [params]: [])] as const;
    }

    
export const getSpeakerInfoSpeakerInfoGetQueryOptions = <TData = Awaited<ReturnType<typeof speakerInfoSpeakerInfoGet>>, TError = AxiosError<HTTPValidationError>>(params: SpeakerInfoSpeakerInfoGetParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof speakerInfoSpeakerInfoGet>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSpeakerInfoSpeakerInfoGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof speakerInfoSpeakerInfoGet>>> = ({ signal }) => speakerInfoSpeakerInfoGet(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof speakerInfoSpeakerInfoGet>>, TError, TData> & { queryKey: QueryKey }
}

export type SpeakerInfoSpeakerInfoGetQueryResult = NonNullable<Awaited<ReturnType<typeof speakerInfoSpeakerInfoGet>>>
export type SpeakerInfoSpeakerInfoGetQueryError = AxiosError<HTTPValidationError>

/**
 * @summary Speaker Info
 */
export const useSpeakerInfoSpeakerInfoGet = <TData = Awaited<ReturnType<typeof speakerInfoSpeakerInfoGet>>, TError = AxiosError<HTTPValidationError>>(
 params: SpeakerInfoSpeakerInfoGetParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof speakerInfoSpeakerInfoGet>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getSpeakerInfoSpeakerInfoGetQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Singers
 */
export const singersSingersGet = (
    params?: SingersSingersGetParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Speaker[]>> => {
    
    return axios.default.get(
      `http://localhost:50021/singers`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getSingersSingersGetQueryKey = (params?: SingersSingersGetParams,) => {
    return [`http://localhost:50021/singers`, ...(params ? [params]: [])] as const;
    }

    
export const getSingersSingersGetQueryOptions = <TData = Awaited<ReturnType<typeof singersSingersGet>>, TError = AxiosError<HTTPValidationError>>(params?: SingersSingersGetParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof singersSingersGet>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSingersSingersGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof singersSingersGet>>> = ({ signal }) => singersSingersGet(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof singersSingersGet>>, TError, TData> & { queryKey: QueryKey }
}

export type SingersSingersGetQueryResult = NonNullable<Awaited<ReturnType<typeof singersSingersGet>>>
export type SingersSingersGetQueryError = AxiosError<HTTPValidationError>

/**
 * @summary Singers
 */
export const useSingersSingersGet = <TData = Awaited<ReturnType<typeof singersSingersGet>>, TError = AxiosError<HTTPValidationError>>(
 params?: SingersSingersGetParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof singersSingersGet>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getSingersSingersGetQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 指定されたspeaker_uuidに関する情報をjson形式で返します。
画像や音声はbase64エンコードされたものが返されます。
 * @summary Singer Info
 */
export const singerInfoSingerInfoGet = (
    params: SingerInfoSingerInfoGetParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SpeakerInfo>> => {
    
    return axios.default.get(
      `http://localhost:50021/singer_info`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getSingerInfoSingerInfoGetQueryKey = (params: SingerInfoSingerInfoGetParams,) => {
    return [`http://localhost:50021/singer_info`, ...(params ? [params]: [])] as const;
    }

    
export const getSingerInfoSingerInfoGetQueryOptions = <TData = Awaited<ReturnType<typeof singerInfoSingerInfoGet>>, TError = AxiosError<HTTPValidationError>>(params: SingerInfoSingerInfoGetParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof singerInfoSingerInfoGet>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSingerInfoSingerInfoGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof singerInfoSingerInfoGet>>> = ({ signal }) => singerInfoSingerInfoGet(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof singerInfoSingerInfoGet>>, TError, TData> & { queryKey: QueryKey }
}

export type SingerInfoSingerInfoGetQueryResult = NonNullable<Awaited<ReturnType<typeof singerInfoSingerInfoGet>>>
export type SingerInfoSingerInfoGetQueryError = AxiosError<HTTPValidationError>

/**
 * @summary Singer Info
 */
export const useSingerInfoSingerInfoGet = <TData = Awaited<ReturnType<typeof singerInfoSingerInfoGet>>, TError = AxiosError<HTTPValidationError>>(
 params: SingerInfoSingerInfoGetParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof singerInfoSingerInfoGet>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getSingerInfoSingerInfoGetQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ダウンロード可能な音声ライブラリの情報を返します。
 * @summary Downloadable Libraries
 */
export const downloadableLibrariesDownloadableLibrariesGet = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<DownloadableLibraryInfo[]>> => {
    
    return axios.default.get(
      `http://localhost:50021/downloadable_libraries`,options
    );
  }


export const getDownloadableLibrariesDownloadableLibrariesGetQueryKey = () => {
    return [`http://localhost:50021/downloadable_libraries`] as const;
    }

    
export const getDownloadableLibrariesDownloadableLibrariesGetQueryOptions = <TData = Awaited<ReturnType<typeof downloadableLibrariesDownloadableLibrariesGet>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof downloadableLibrariesDownloadableLibrariesGet>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDownloadableLibrariesDownloadableLibrariesGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof downloadableLibrariesDownloadableLibrariesGet>>> = ({ signal }) => downloadableLibrariesDownloadableLibrariesGet({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof downloadableLibrariesDownloadableLibrariesGet>>, TError, TData> & { queryKey: QueryKey }
}

export type DownloadableLibrariesDownloadableLibrariesGetQueryResult = NonNullable<Awaited<ReturnType<typeof downloadableLibrariesDownloadableLibrariesGet>>>
export type DownloadableLibrariesDownloadableLibrariesGetQueryError = AxiosError<unknown>

/**
 * @summary Downloadable Libraries
 */
export const useDownloadableLibrariesDownloadableLibrariesGet = <TData = Awaited<ReturnType<typeof downloadableLibrariesDownloadableLibrariesGet>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof downloadableLibrariesDownloadableLibrariesGet>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getDownloadableLibrariesDownloadableLibrariesGetQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * インストールした音声ライブラリの情報を返します。
 * @summary Installed Libraries
 */
export const installedLibrariesInstalledLibrariesGet = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<InstalledLibrariesInstalledLibrariesGet200>> => {
    
    return axios.default.get(
      `http://localhost:50021/installed_libraries`,options
    );
  }


export const getInstalledLibrariesInstalledLibrariesGetQueryKey = () => {
    return [`http://localhost:50021/installed_libraries`] as const;
    }

    
export const getInstalledLibrariesInstalledLibrariesGetQueryOptions = <TData = Awaited<ReturnType<typeof installedLibrariesInstalledLibrariesGet>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof installedLibrariesInstalledLibrariesGet>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInstalledLibrariesInstalledLibrariesGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof installedLibrariesInstalledLibrariesGet>>> = ({ signal }) => installedLibrariesInstalledLibrariesGet({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof installedLibrariesInstalledLibrariesGet>>, TError, TData> & { queryKey: QueryKey }
}

export type InstalledLibrariesInstalledLibrariesGetQueryResult = NonNullable<Awaited<ReturnType<typeof installedLibrariesInstalledLibrariesGet>>>
export type InstalledLibrariesInstalledLibrariesGetQueryError = AxiosError<unknown>

/**
 * @summary Installed Libraries
 */
export const useInstalledLibrariesInstalledLibrariesGet = <TData = Awaited<ReturnType<typeof installedLibrariesInstalledLibrariesGet>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof installedLibrariesInstalledLibrariesGet>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getInstalledLibrariesInstalledLibrariesGetQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 音声ライブラリをインストールします。
音声ライブラリのZIPファイルをリクエストボディとして送信してください。
 * @summary Install Library
 */
export const installLibraryInstallLibraryLibraryUuidPost = (
    libraryUuid: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.default.post(
      `http://localhost:50021/install_library/${libraryUuid}`,undefined,options
    );
  }



export const getInstallLibraryInstallLibraryLibraryUuidPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof installLibraryInstallLibraryLibraryUuidPost>>, TError,{libraryUuid: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof installLibraryInstallLibraryLibraryUuidPost>>, TError,{libraryUuid: string}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof installLibraryInstallLibraryLibraryUuidPost>>, {libraryUuid: string}> = (props) => {
          const {libraryUuid} = props ?? {};

          return  installLibraryInstallLibraryLibraryUuidPost(libraryUuid,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InstallLibraryInstallLibraryLibraryUuidPostMutationResult = NonNullable<Awaited<ReturnType<typeof installLibraryInstallLibraryLibraryUuidPost>>>
    
    export type InstallLibraryInstallLibraryLibraryUuidPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Install Library
 */
export const useInstallLibraryInstallLibraryLibraryUuidPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof installLibraryInstallLibraryLibraryUuidPost>>, TError,{libraryUuid: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof installLibraryInstallLibraryLibraryUuidPost>>,
        TError,
        {libraryUuid: string},
        TContext
      > => {

      const mutationOptions = getInstallLibraryInstallLibraryLibraryUuidPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * 音声ライブラリをアンインストールします。
 * @summary Uninstall Library
 */
export const uninstallLibraryUninstallLibraryLibraryUuidPost = (
    libraryUuid: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.default.post(
      `http://localhost:50021/uninstall_library/${libraryUuid}`,undefined,options
    );
  }



export const getUninstallLibraryUninstallLibraryLibraryUuidPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uninstallLibraryUninstallLibraryLibraryUuidPost>>, TError,{libraryUuid: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof uninstallLibraryUninstallLibraryLibraryUuidPost>>, TError,{libraryUuid: string}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof uninstallLibraryUninstallLibraryLibraryUuidPost>>, {libraryUuid: string}> = (props) => {
          const {libraryUuid} = props ?? {};

          return  uninstallLibraryUninstallLibraryLibraryUuidPost(libraryUuid,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UninstallLibraryUninstallLibraryLibraryUuidPostMutationResult = NonNullable<Awaited<ReturnType<typeof uninstallLibraryUninstallLibraryLibraryUuidPost>>>
    
    export type UninstallLibraryUninstallLibraryLibraryUuidPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Uninstall Library
 */
export const useUninstallLibraryUninstallLibraryLibraryUuidPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uninstallLibraryUninstallLibraryLibraryUuidPost>>, TError,{libraryUuid: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof uninstallLibraryUninstallLibraryLibraryUuidPost>>,
        TError,
        {libraryUuid: string},
        TContext
      > => {

      const mutationOptions = getUninstallLibraryUninstallLibraryLibraryUuidPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * 指定されたスタイルを初期化します。
実行しなくても他のAPIは使用できますが、初回実行時に時間がかかることがあります。
 * @summary Initialize Speaker
 */
export const initializeSpeakerInitializeSpeakerPost = (
    params: InitializeSpeakerInitializeSpeakerPostParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.default.post(
      `http://localhost:50021/initialize_speaker`,undefined,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getInitializeSpeakerInitializeSpeakerPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof initializeSpeakerInitializeSpeakerPost>>, TError,{params: InitializeSpeakerInitializeSpeakerPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof initializeSpeakerInitializeSpeakerPost>>, TError,{params: InitializeSpeakerInitializeSpeakerPostParams}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof initializeSpeakerInitializeSpeakerPost>>, {params: InitializeSpeakerInitializeSpeakerPostParams}> = (props) => {
          const {params} = props ?? {};

          return  initializeSpeakerInitializeSpeakerPost(params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InitializeSpeakerInitializeSpeakerPostMutationResult = NonNullable<Awaited<ReturnType<typeof initializeSpeakerInitializeSpeakerPost>>>
    
    export type InitializeSpeakerInitializeSpeakerPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Initialize Speaker
 */
export const useInitializeSpeakerInitializeSpeakerPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof initializeSpeakerInitializeSpeakerPost>>, TError,{params: InitializeSpeakerInitializeSpeakerPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof initializeSpeakerInitializeSpeakerPost>>,
        TError,
        {params: InitializeSpeakerInitializeSpeakerPostParams},
        TContext
      > => {

      const mutationOptions = getInitializeSpeakerInitializeSpeakerPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * 指定されたスタイルが初期化されているかどうかを返します。
 * @summary Is Initialized Speaker
 */
export const isInitializedSpeakerIsInitializedSpeakerGet = (
    params: IsInitializedSpeakerIsInitializedSpeakerGetParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<boolean>> => {
    
    return axios.default.get(
      `http://localhost:50021/is_initialized_speaker`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getIsInitializedSpeakerIsInitializedSpeakerGetQueryKey = (params: IsInitializedSpeakerIsInitializedSpeakerGetParams,) => {
    return [`http://localhost:50021/is_initialized_speaker`, ...(params ? [params]: [])] as const;
    }

    
export const getIsInitializedSpeakerIsInitializedSpeakerGetQueryOptions = <TData = Awaited<ReturnType<typeof isInitializedSpeakerIsInitializedSpeakerGet>>, TError = AxiosError<HTTPValidationError>>(params: IsInitializedSpeakerIsInitializedSpeakerGetParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof isInitializedSpeakerIsInitializedSpeakerGet>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getIsInitializedSpeakerIsInitializedSpeakerGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof isInitializedSpeakerIsInitializedSpeakerGet>>> = ({ signal }) => isInitializedSpeakerIsInitializedSpeakerGet(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof isInitializedSpeakerIsInitializedSpeakerGet>>, TError, TData> & { queryKey: QueryKey }
}

export type IsInitializedSpeakerIsInitializedSpeakerGetQueryResult = NonNullable<Awaited<ReturnType<typeof isInitializedSpeakerIsInitializedSpeakerGet>>>
export type IsInitializedSpeakerIsInitializedSpeakerGetQueryError = AxiosError<HTTPValidationError>

/**
 * @summary Is Initialized Speaker
 */
export const useIsInitializedSpeakerIsInitializedSpeakerGet = <TData = Awaited<ReturnType<typeof isInitializedSpeakerIsInitializedSpeakerGet>>, TError = AxiosError<HTTPValidationError>>(
 params: IsInitializedSpeakerIsInitializedSpeakerGetParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof isInitializedSpeakerIsInitializedSpeakerGet>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getIsInitializedSpeakerIsInitializedSpeakerGetQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ユーザー辞書に登録されている単語の一覧を返します。
単語の表層形(surface)は正規化済みの物を返します。
 * @summary Get User Dict Words
 */
export const getUserDictWordsUserDictGet = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetUserDictWordsUserDictGet200>> => {
    
    return axios.default.get(
      `http://localhost:50021/user_dict`,options
    );
  }


export const getGetUserDictWordsUserDictGetQueryKey = () => {
    return [`http://localhost:50021/user_dict`] as const;
    }

    
export const getGetUserDictWordsUserDictGetQueryOptions = <TData = Awaited<ReturnType<typeof getUserDictWordsUserDictGet>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUserDictWordsUserDictGet>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserDictWordsUserDictGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserDictWordsUserDictGet>>> = ({ signal }) => getUserDictWordsUserDictGet({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserDictWordsUserDictGet>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserDictWordsUserDictGetQueryResult = NonNullable<Awaited<ReturnType<typeof getUserDictWordsUserDictGet>>>
export type GetUserDictWordsUserDictGetQueryError = AxiosError<unknown>

/**
 * @summary Get User Dict Words
 */
export const useGetUserDictWordsUserDictGet = <TData = Awaited<ReturnType<typeof getUserDictWordsUserDictGet>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUserDictWordsUserDictGet>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUserDictWordsUserDictGetQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ユーザー辞書に言葉を追加します。
 * @summary Add User Dict Word
 */
export const addUserDictWordUserDictWordPost = (
    params: AddUserDictWordUserDictWordPostParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    
    return axios.default.post(
      `http://localhost:50021/user_dict_word`,undefined,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getAddUserDictWordUserDictWordPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addUserDictWordUserDictWordPost>>, TError,{params: AddUserDictWordUserDictWordPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof addUserDictWordUserDictWordPost>>, TError,{params: AddUserDictWordUserDictWordPostParams}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addUserDictWordUserDictWordPost>>, {params: AddUserDictWordUserDictWordPostParams}> = (props) => {
          const {params} = props ?? {};

          return  addUserDictWordUserDictWordPost(params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddUserDictWordUserDictWordPostMutationResult = NonNullable<Awaited<ReturnType<typeof addUserDictWordUserDictWordPost>>>
    
    export type AddUserDictWordUserDictWordPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Add User Dict Word
 */
export const useAddUserDictWordUserDictWordPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addUserDictWordUserDictWordPost>>, TError,{params: AddUserDictWordUserDictWordPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof addUserDictWordUserDictWordPost>>,
        TError,
        {params: AddUserDictWordUserDictWordPostParams},
        TContext
      > => {

      const mutationOptions = getAddUserDictWordUserDictWordPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * ユーザー辞書に登録されている言葉を更新します。
 * @summary Rewrite User Dict Word
 */
export const rewriteUserDictWordUserDictWordWordUuidPut = (
    wordUuid: string,
    params: RewriteUserDictWordUserDictWordWordUuidPutParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.default.put(
      `http://localhost:50021/user_dict_word/${wordUuid}`,undefined,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getRewriteUserDictWordUserDictWordWordUuidPutMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof rewriteUserDictWordUserDictWordWordUuidPut>>, TError,{wordUuid: string;params: RewriteUserDictWordUserDictWordWordUuidPutParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof rewriteUserDictWordUserDictWordWordUuidPut>>, TError,{wordUuid: string;params: RewriteUserDictWordUserDictWordWordUuidPutParams}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof rewriteUserDictWordUserDictWordWordUuidPut>>, {wordUuid: string;params: RewriteUserDictWordUserDictWordWordUuidPutParams}> = (props) => {
          const {wordUuid,params} = props ?? {};

          return  rewriteUserDictWordUserDictWordWordUuidPut(wordUuid,params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RewriteUserDictWordUserDictWordWordUuidPutMutationResult = NonNullable<Awaited<ReturnType<typeof rewriteUserDictWordUserDictWordWordUuidPut>>>
    
    export type RewriteUserDictWordUserDictWordWordUuidPutMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Rewrite User Dict Word
 */
export const useRewriteUserDictWordUserDictWordWordUuidPut = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof rewriteUserDictWordUserDictWordWordUuidPut>>, TError,{wordUuid: string;params: RewriteUserDictWordUserDictWordWordUuidPutParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof rewriteUserDictWordUserDictWordWordUuidPut>>,
        TError,
        {wordUuid: string;params: RewriteUserDictWordUserDictWordWordUuidPutParams},
        TContext
      > => {

      const mutationOptions = getRewriteUserDictWordUserDictWordWordUuidPutMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * ユーザー辞書に登録されている言葉を削除します。
 * @summary Delete User Dict Word
 */
export const deleteUserDictWordUserDictWordWordUuidDelete = (
    wordUuid: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.default.delete(
      `http://localhost:50021/user_dict_word/${wordUuid}`,options
    );
  }



export const getDeleteUserDictWordUserDictWordWordUuidDeleteMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUserDictWordUserDictWordWordUuidDelete>>, TError,{wordUuid: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteUserDictWordUserDictWordWordUuidDelete>>, TError,{wordUuid: string}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUserDictWordUserDictWordWordUuidDelete>>, {wordUuid: string}> = (props) => {
          const {wordUuid} = props ?? {};

          return  deleteUserDictWordUserDictWordWordUuidDelete(wordUuid,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteUserDictWordUserDictWordWordUuidDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUserDictWordUserDictWordWordUuidDelete>>>
    
    export type DeleteUserDictWordUserDictWordWordUuidDeleteMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Delete User Dict Word
 */
export const useDeleteUserDictWordUserDictWordWordUuidDelete = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUserDictWordUserDictWordWordUuidDelete>>, TError,{wordUuid: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteUserDictWordUserDictWordWordUuidDelete>>,
        TError,
        {wordUuid: string},
        TContext
      > => {

      const mutationOptions = getDeleteUserDictWordUserDictWordWordUuidDeleteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * 他のユーザー辞書をインポートします。
 * @summary Import User Dict Words
 */
export const importUserDictWordsImportUserDictPost = (
    importUserDictWordsImportUserDictPostBody: ImportUserDictWordsImportUserDictPostBody,
    params: ImportUserDictWordsImportUserDictPostParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.default.post(
      `http://localhost:50021/import_user_dict`,
      importUserDictWordsImportUserDictPostBody,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getImportUserDictWordsImportUserDictPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof importUserDictWordsImportUserDictPost>>, TError,{data: ImportUserDictWordsImportUserDictPostBody;params: ImportUserDictWordsImportUserDictPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof importUserDictWordsImportUserDictPost>>, TError,{data: ImportUserDictWordsImportUserDictPostBody;params: ImportUserDictWordsImportUserDictPostParams}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof importUserDictWordsImportUserDictPost>>, {data: ImportUserDictWordsImportUserDictPostBody;params: ImportUserDictWordsImportUserDictPostParams}> = (props) => {
          const {data,params} = props ?? {};

          return  importUserDictWordsImportUserDictPost(data,params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ImportUserDictWordsImportUserDictPostMutationResult = NonNullable<Awaited<ReturnType<typeof importUserDictWordsImportUserDictPost>>>
    export type ImportUserDictWordsImportUserDictPostMutationBody = ImportUserDictWordsImportUserDictPostBody
    export type ImportUserDictWordsImportUserDictPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Import User Dict Words
 */
export const useImportUserDictWordsImportUserDictPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof importUserDictWordsImportUserDictPost>>, TError,{data: ImportUserDictWordsImportUserDictPostBody;params: ImportUserDictWordsImportUserDictPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof importUserDictWordsImportUserDictPost>>,
        TError,
        {data: ImportUserDictWordsImportUserDictPostBody;params: ImportUserDictWordsImportUserDictPostParams},
        TContext
      > => {

      const mutationOptions = getImportUserDictWordsImportUserDictPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Supported Devices
 */
export const supportedDevicesSupportedDevicesGet = (
    params?: SupportedDevicesSupportedDevicesGetParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SupportedDevicesInfo>> => {
    
    return axios.default.get(
      `http://localhost:50021/supported_devices`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getSupportedDevicesSupportedDevicesGetQueryKey = (params?: SupportedDevicesSupportedDevicesGetParams,) => {
    return [`http://localhost:50021/supported_devices`, ...(params ? [params]: [])] as const;
    }

    
export const getSupportedDevicesSupportedDevicesGetQueryOptions = <TData = Awaited<ReturnType<typeof supportedDevicesSupportedDevicesGet>>, TError = AxiosError<HTTPValidationError>>(params?: SupportedDevicesSupportedDevicesGetParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof supportedDevicesSupportedDevicesGet>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSupportedDevicesSupportedDevicesGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof supportedDevicesSupportedDevicesGet>>> = ({ signal }) => supportedDevicesSupportedDevicesGet(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof supportedDevicesSupportedDevicesGet>>, TError, TData> & { queryKey: QueryKey }
}

export type SupportedDevicesSupportedDevicesGetQueryResult = NonNullable<Awaited<ReturnType<typeof supportedDevicesSupportedDevicesGet>>>
export type SupportedDevicesSupportedDevicesGetQueryError = AxiosError<HTTPValidationError>

/**
 * @summary Supported Devices
 */
export const useSupportedDevicesSupportedDevicesGet = <TData = Awaited<ReturnType<typeof supportedDevicesSupportedDevicesGet>>, TError = AxiosError<HTTPValidationError>>(
 params?: SupportedDevicesSupportedDevicesGetParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof supportedDevicesSupportedDevicesGet>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getSupportedDevicesSupportedDevicesGetQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Engine Manifest
 */
export const engineManifestEngineManifestGet = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<EngineManifest>> => {
    
    return axios.default.get(
      `http://localhost:50021/engine_manifest`,options
    );
  }


export const getEngineManifestEngineManifestGetQueryKey = () => {
    return [`http://localhost:50021/engine_manifest`] as const;
    }

    
export const getEngineManifestEngineManifestGetQueryOptions = <TData = Awaited<ReturnType<typeof engineManifestEngineManifestGet>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof engineManifestEngineManifestGet>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getEngineManifestEngineManifestGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof engineManifestEngineManifestGet>>> = ({ signal }) => engineManifestEngineManifestGet({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof engineManifestEngineManifestGet>>, TError, TData> & { queryKey: QueryKey }
}

export type EngineManifestEngineManifestGetQueryResult = NonNullable<Awaited<ReturnType<typeof engineManifestEngineManifestGet>>>
export type EngineManifestEngineManifestGetQueryError = AxiosError<unknown>

/**
 * @summary Engine Manifest
 */
export const useEngineManifestEngineManifestGet = <TData = Awaited<ReturnType<typeof engineManifestEngineManifestGet>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof engineManifestEngineManifestGet>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getEngineManifestEngineManifestGetQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 設定ページを返します。
 * @summary Setting Get
 */
export const settingGetSettingGet = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.default.get(
      `http://localhost:50021/setting`,options
    );
  }


export const getSettingGetSettingGetQueryKey = () => {
    return [`http://localhost:50021/setting`] as const;
    }

    
export const getSettingGetSettingGetQueryOptions = <TData = Awaited<ReturnType<typeof settingGetSettingGet>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof settingGetSettingGet>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSettingGetSettingGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof settingGetSettingGet>>> = ({ signal }) => settingGetSettingGet({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof settingGetSettingGet>>, TError, TData> & { queryKey: QueryKey }
}

export type SettingGetSettingGetQueryResult = NonNullable<Awaited<ReturnType<typeof settingGetSettingGet>>>
export type SettingGetSettingGetQueryError = AxiosError<unknown>

/**
 * @summary Setting Get
 */
export const useSettingGetSettingGet = <TData = Awaited<ReturnType<typeof settingGetSettingGet>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof settingGetSettingGet>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getSettingGetSettingGetQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * 設定を更新します。
 * @summary Setting Post
 */
export const settingPostSettingPost = (
    bodySettingPostSettingPost: BodySettingPostSettingPost, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {const formUrlEncoded = new URLSearchParams();
formUrlEncoded.append('cors_policy_mode', bodySettingPostSettingPost.cors_policy_mode)
if(bodySettingPostSettingPost.allow_origin !== undefined) {
 formUrlEncoded.append('allow_origin', bodySettingPostSettingPost.allow_origin)
 }

    
    return axios.default.post(
      `http://localhost:50021/setting`,
      formUrlEncoded,options
    );
  }



export const getSettingPostSettingPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof settingPostSettingPost>>, TError,{data: BodySettingPostSettingPost}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof settingPostSettingPost>>, TError,{data: BodySettingPostSettingPost}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof settingPostSettingPost>>, {data: BodySettingPostSettingPost}> = (props) => {
          const {data} = props ?? {};

          return  settingPostSettingPost(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SettingPostSettingPostMutationResult = NonNullable<Awaited<ReturnType<typeof settingPostSettingPost>>>
    export type SettingPostSettingPostMutationBody = BodySettingPostSettingPost
    export type SettingPostSettingPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Setting Post
 */
export const useSettingPostSettingPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof settingPostSettingPost>>, TError,{data: BodySettingPostSettingPost}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof settingPostSettingPost>>,
        TError,
        {data: BodySettingPostSettingPost},
        TContext
      > => {

      const mutationOptions = getSettingPostSettingPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
