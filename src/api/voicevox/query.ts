/**
 * Generated by orval v6.28.2 ğŸº
 * Do not edit manually.
 * VOICEVOX Engine
 * VOICEVOXã®éŸ³å£°åˆæˆã‚¨ãƒ³ã‚¸ãƒ³ã§ã™ã€‚
 * OpenAPI spec version: 0.19.0
 */
import * as axios from 'axios';
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios'
import {
  useMutation,
  useQuery
} from 'react-query'
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from 'react-query'
export type SupportedDevicesSupportedDevicesGetParams = {
core_version?: string;
};

/**
 * ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹ãƒ¦ãƒ¼ã‚¶ãƒ¼è¾æ›¸ã®ãƒ‡ãƒ¼ã‚¿
 */
export type ImportUserDictWordsImportUserDictPostBody = {[key: string]: UserDictWord};

export type ImportUserDictWordsImportUserDictPostParams = {
/**
 * é‡è¤‡ã—ãŸã‚¨ãƒ³ãƒˆãƒªãŒã‚ã£ãŸå ´åˆã€ä¸Šæ›¸ãã™ã‚‹ã‹ã©ã†ã‹
 */
override: boolean;
};

export type RewriteUserDictWordUserDictWordWordUuidPutParams = {
/**
 * è¨€è‘‰ã®è¡¨å±¤å½¢
 */
surface: string;
/**
 * è¨€è‘‰ã®ç™ºéŸ³ï¼ˆã‚«ã‚¿ã‚«ãƒŠï¼‰
 */
pronunciation: string;
/**
 * ã‚¢ã‚¯ã‚»ãƒ³ãƒˆå‹ï¼ˆéŸ³ãŒä¸‹ãŒã‚‹å ´æ‰€ã‚’æŒ‡ã™ï¼‰
 */
accent_type: number;
/**
 * PROPER_NOUNï¼ˆå›ºæœ‰åè©ï¼‰ã€COMMON_NOUNï¼ˆæ™®é€šåè©ï¼‰ã€VERBï¼ˆå‹•è©ï¼‰ã€ADJECTIVEï¼ˆå½¢å®¹è©ï¼‰ã€SUFFIXï¼ˆèªå°¾ï¼‰ã®ã„ãšã‚Œã‹
 */
word_type?: WordTypes;
/**
 * å˜èªã®å„ªå…ˆåº¦ï¼ˆ0ã‹ã‚‰10ã¾ã§ã®æ•´æ•°ï¼‰ã€‚æ•°å­—ãŒå¤§ãã„ã»ã©å„ªå…ˆåº¦ãŒé«˜ããªã‚‹ã€‚1ã‹ã‚‰9ã¾ã§ã®å€¤ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ã‚’æ¨å¥¨ã€‚
 */
priority?: number;
};

export type AddUserDictWordUserDictWordPostParams = {
/**
 * è¨€è‘‰ã®è¡¨å±¤å½¢
 */
surface: string;
/**
 * è¨€è‘‰ã®ç™ºéŸ³ï¼ˆã‚«ã‚¿ã‚«ãƒŠï¼‰
 */
pronunciation: string;
/**
 * ã‚¢ã‚¯ã‚»ãƒ³ãƒˆå‹ï¼ˆéŸ³ãŒä¸‹ãŒã‚‹å ´æ‰€ã‚’æŒ‡ã™ï¼‰
 */
accent_type: number;
/**
 * PROPER_NOUNï¼ˆå›ºæœ‰åè©ï¼‰ã€COMMON_NOUNï¼ˆæ™®é€šåè©ï¼‰ã€VERBï¼ˆå‹•è©ï¼‰ã€ADJECTIVEï¼ˆå½¢å®¹è©ï¼‰ã€SUFFIXï¼ˆèªå°¾ï¼‰ã®ã„ãšã‚Œã‹
 */
word_type?: WordTypes;
/**
 * å˜èªã®å„ªå…ˆåº¦ï¼ˆ0ã‹ã‚‰10ã¾ã§ã®æ•´æ•°ï¼‰ã€‚æ•°å­—ãŒå¤§ãã„ã»ã©å„ªå…ˆåº¦ãŒé«˜ããªã‚‹ã€‚1ã‹ã‚‰9ã¾ã§ã®å€¤ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ã‚’æ¨å¥¨
 */
priority?: number;
};

export type GetUserDictWordsUserDictGet200 = {[key: string]: UserDictWord};

export type IsInitializedSpeakerIsInitializedSpeakerGetParams = {
speaker: number;
core_version?: string;
};

export type InitializeSpeakerInitializeSpeakerPostParams = {
speaker: number;
/**
 * æ—¢ã«åˆæœŸåŒ–æ¸ˆã¿ã®ã‚¹ã‚¿ã‚¤ãƒ«ã®å†åˆæœŸåŒ–ã‚’ã‚¹ã‚­ãƒƒãƒ—ã™ã‚‹ã‹ã©ã†ã‹
 */
skip_reinit?: boolean;
core_version?: string;
};

export type InstalledLibrariesInstalledLibrariesGet200 = {[key: string]: InstalledLibraryInfo};

export type SingerInfoSingerInfoGetParams = {
speaker_uuid: string;
core_version?: string;
};

export type SingersSingersGetParams = {
core_version?: string;
};

export type SpeakerInfoSpeakerInfoGetParams = {
speaker_uuid: string;
core_version?: string;
};

export type SpeakersSpeakersGetParams = {
core_version?: string;
};

export type DeletePresetDeletePresetPostParams = {
/**
 * å‰Šé™¤ã™ã‚‹ãƒ—ãƒªã‚»ãƒƒãƒˆã®ãƒ—ãƒªã‚»ãƒƒãƒˆID
 */
id: number;
};

export type SynthesisMorphingSynthesisMorphingPostParams = {
base_speaker: number;
target_speaker: number;
morph_rate: number;
core_version?: string;
};

export type MorphableTargetsMorphableTargetsPost200Item = {[key: string]: MorphableTargetInfo};

export type MorphableTargetsMorphableTargetsPostParams = {
core_version?: string;
};

export type ValidateKanaValidateKanaPostParams = {
/**
 * åˆ¤å®šã™ã‚‹å¯¾è±¡ã®æ–‡å­—åˆ—
 */
text: string;
};

export type FrameSynthesisFrameSynthesisPostParams = {
speaker: number;
core_version?: string;
};

export type SingFrameVolumeSingFrameVolumePostParams = {
speaker: number;
core_version?: string;
};

export type SingFrameAudioQuerySingFrameAudioQueryPostParams = {
speaker: number;
core_version?: string;
};

export type MultiSynthesisMultiSynthesisPostParams = {
speaker: number;
core_version?: string;
};

export type CancellableSynthesisCancellableSynthesisPostParams = {
speaker: number;
core_version?: string;
};

export type SynthesisSynthesisPostParams = {
speaker: number;
/**
 * ç–‘å•ç³»ã®ãƒ†ã‚­ã‚¹ãƒˆãŒä¸ãˆã‚‰ã‚ŒãŸã‚‰èªå°¾ã‚’è‡ªå‹•èª¿æ•´ã™ã‚‹
 */
enable_interrogative_upspeak?: boolean;
core_version?: string;
};

export type MoraPitchMoraPitchPostParams = {
speaker: number;
core_version?: string;
};

export type MoraLengthMoraLengthPostParams = {
speaker: number;
core_version?: string;
};

export type MoraDataMoraDataPostParams = {
speaker: number;
core_version?: string;
};

export type AccentPhrasesAccentPhrasesPostParams = {
text: string;
speaker: number;
is_kana?: boolean;
core_version?: string;
};

export type AudioQueryFromPresetAudioQueryFromPresetPostParams = {
text: string;
preset_id: number;
core_version?: string;
};

export type AudioQueryAudioQueryPostParams = {
text: string;
speaker: number;
core_version?: string;
};

/**
 * éŸ³å£°ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®æƒ…å ±
 */
export interface BaseLibraryInfo {
  bytes: number;
  download_url: string;
  name: string;
  speakers: LibrarySpeaker[];
  uuid: string;
  version: string;
}

/**
 * vvlib(VOICEVOX Library)ã«é–¢ã™ã‚‹æƒ…å ±
 */
export interface VvlibManifest {
  brand_name: string;
  engine_name: string;
  engine_uuid: string;
  manifest_version: string;
  name: string;
  uuid: string;
  version: string;
}

/**
 * fastapiã§word_typeå¼•æ•°ã‚’æ¤œè¨¼ã™ã‚‹æ™‚ã«ä½¿ç”¨ã™ã‚‹ã‚¯ãƒ©ã‚¹
 */
export type WordTypes = typeof WordTypes[keyof typeof WordTypes];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const WordTypes = {
  PROPER_NOUN: 'PROPER_NOUN',
  COMMON_NOUN: 'COMMON_NOUN',
  VERB: 'VERB',
  ADJECTIVE: 'ADJECTIVE',
  SUFFIX: 'SUFFIX',
} as const;

export type ValidationErrorLocItem = string | number;

export interface ValidationError {
  loc: ValidationErrorLocItem[];
  msg: string;
  type: string;
}

/**
 * è¾æ›¸ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã«ä½¿ã‚ã‚Œã‚‹æƒ…å ±
 */
export interface UserDictWord {
  accent_associative_rule: string;
  accent_type: number;
  context_id?: number;
  inflectional_form: string;
  inflectional_type: string;
  mora_count?: number;
  part_of_speech: string;
  part_of_speech_detail_1: string;
  part_of_speech_detail_2: string;
  part_of_speech_detail_3: string;
  /**
   * @minimum 0
   * @maximum 10
   */
  priority: number;
  pronunciation: string;
  stem: string;
  surface: string;
  yomi: string;
}

/**
 * ã‚¨ãƒ³ã‚¸ãƒ³ã®ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆæƒ…å ±
 */
export interface UpdateInfo {
  contributors?: string[];
  descriptions: string[];
  version: string;
}

/**
 * ã‚¨ãƒ³ã‚¸ãƒ³ãŒæŒã¤æ©Ÿèƒ½ã®ä¸€è¦§
 */
export interface SupportedFeatures {
  adjust_intonation_scale: boolean;
  adjust_mora_pitch: boolean;
  adjust_phoneme_length: boolean;
  adjust_pitch_scale: boolean;
  adjust_speed_scale: boolean;
  adjust_volume_scale: boolean;
  interrogative_upspeak: boolean;
  manage_library?: boolean;
  sing?: boolean;
  synthesis_morphing: boolean;
}

/**
 * å¯¾å¿œã—ã¦ã„ã‚‹ãƒ‡ãƒã‚¤ã‚¹ã®æƒ…å ±
 */
export interface SupportedDevicesInfo {
  cpu: boolean;
  cuda: boolean;
  dml: boolean;
}

/**
 * ã‚¹ã‚¿ã‚¤ãƒ«ã®è¿½åŠ æƒ…å ±
 */
export interface StyleInfo {
  icon: string;
  id: number;
  portrait?: string;
  voice_samples: string[];
}

/**
 * An enumeration.
 */
export type SpeakerSupportPermittedSynthesisMorphing = typeof SpeakerSupportPermittedSynthesisMorphing[keyof typeof SpeakerSupportPermittedSynthesisMorphing];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SpeakerSupportPermittedSynthesisMorphing = {
  ALL: 'ALL',
  SELF_ONLY: 'SELF_ONLY',
  NOTHING: 'NOTHING',
} as const;

/**
 * è©±è€…ã®å¯¾å¿œæ©Ÿèƒ½ã®æƒ…å ±
 */
export interface SpeakerSupportedFeatures {
  permitted_synthesis_morphing?: SpeakerSupportPermittedSynthesisMorphing;
}

export type SpeakerStyleType = typeof SpeakerStyleType[keyof typeof SpeakerStyleType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SpeakerStyleType = {
  talk: 'talk',
  singing_teacher: 'singing_teacher',
  frame_decode: 'frame_decode',
  sing: 'sing',
} as const;

/**
 * è©±è€…ã®ã‚¹ã‚¿ã‚¤ãƒ«æƒ…å ±
 */
export interface SpeakerStyle {
  id: number;
  name: string;
  type?: SpeakerStyleType;
}

/**
 * è©±è€…ã®è¿½åŠ æƒ…å ±
 */
export interface SpeakerInfo {
  policy: string;
  portrait: string;
  style_infos: StyleInfo[];
}

/**
 * è©±è€…æƒ…å ±
 */
export interface Speaker {
  name: string;
  speaker_uuid: string;
  styles: SpeakerStyle[];
  supported_features?: SpeakerSupportedFeatures;
  version?: string;
}

/**
 * æ¥½è­œæƒ…å ±
 */
export interface Score {
  notes: Note[];
}

/**
 * ãƒ—ãƒªã‚»ãƒƒãƒˆæƒ…å ±
 */
export interface Preset {
  id: number;
  intonationScale: number;
  name: string;
  pitchScale: number;
  postPhonemeLength: number;
  prePhonemeLength: number;
  speaker_uuid: string;
  speedScale: number;
  style_id: number;
  volumeScale: number;
}

export type ParseKanaBadRequestErrorArgs = {[key: string]: string};

export interface ParseKanaBadRequest {
  error_args: ParseKanaBadRequestErrorArgs;
  /** |name|description|
|---|---|
| UNKNOWN_TEXT | åˆ¤åˆ¥ã§ããªã„èª­ã¿ä»®åãŒã‚ã‚Šã¾ã™: {text} |
| ACCENT_TOP | å¥é ­ã«ã‚¢ã‚¯ã‚»ãƒ³ãƒˆã¯ç½®ã‘ã¾ã›ã‚“: {text} |
| ACCENT_TWICE | 1ã¤ã®ã‚¢ã‚¯ã‚»ãƒ³ãƒˆå¥ã«äºŒã¤ä»¥ä¸Šã®ã‚¢ã‚¯ã‚»ãƒ³ãƒˆã¯ç½®ã‘ã¾ã›ã‚“: {text} |
| ACCENT_NOTFOUND | ã‚¢ã‚¯ã‚»ãƒ³ãƒˆã‚’æŒ‡å®šã—ã¦ã„ãªã„ã‚¢ã‚¯ã‚»ãƒ³ãƒˆå¥ãŒã‚ã‚Šã¾ã™: {text} |
| EMPTY_PHRASE | {position}ç•ªç›®ã®ã‚¢ã‚¯ã‚»ãƒ³ãƒˆå¥ãŒç©ºç™½ã§ã™ |
| INTERROGATION_MARK_NOT_AT_END | ã‚¢ã‚¯ã‚»ãƒ³ãƒˆå¥æœ«ä»¥å¤–ã«ã€Œï¼Ÿã€ã¯ç½®ã‘ã¾ã›ã‚“: {text} |
| INFINITE_LOOP | å‡¦ç†æ™‚ã«ç„¡é™ãƒ«ãƒ¼ãƒ—ã«ãªã£ã¦ã—ã¾ã„ã¾ã—ãŸ...ãƒã‚°å ±å‘Šã‚’ãŠé¡˜ã„ã—ã¾ã™ã€‚ | */
  error_name: string;
  text: string;
}

/**
 * éŸ³ç¬¦ã”ã¨ã®æƒ…å ±
 */
export interface Note {
  frame_length: number;
  key?: number;
  lyric: string;
}

export interface MorphableTargetInfo {
  is_morphable: boolean;
}

/**
 * ãƒ¢ãƒ¼ãƒ©ï¼ˆå­éŸ³ï¼‹æ¯éŸ³ï¼‰ã”ã¨ã®æƒ…å ±
 */
export interface Mora {
  consonant?: string;
  consonant_length?: number;
  pitch: number;
  text: string;
  vowel: string;
  vowel_length: number;
}

/**
 * ä¾å­˜ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ãƒ©ã‚¤ã‚»ãƒ³ã‚¹æƒ…å ±
 */
export interface LicenseInfo {
  license?: string;
  name: string;
  text: string;
  version?: string;
}

/**
 * éŸ³å£°ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«å«ã¾ã‚Œã‚‹è©±è€…ã®æƒ…å ±
 */
export interface LibrarySpeaker {
  speaker: Speaker;
  speaker_info: SpeakerInfo;
}

/**
 * ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æ¸ˆã¿éŸ³å£°ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®æƒ…å ±
 */
export interface InstalledLibraryInfo {
  bytes: number;
  download_url: string;
  name: string;
  speakers: LibrarySpeaker[];
  uninstallable: boolean;
  uuid: string;
  version: string;
}

export interface HTTPValidationError {
  detail?: ValidationError[];
}

/**
 * éŸ³ç´ ã®æƒ…å ±
 */
export interface FramePhoneme {
  frame_length: number;
  phoneme: string;
}

/**
 * ãƒ•ãƒ¬ãƒ¼ãƒ ã”ã¨ã®éŸ³å£°åˆæˆç”¨ã®ã‚¯ã‚¨ãƒª
 */
export interface FrameAudioQuery {
  f0: number[];
  outputSamplingRate: number;
  outputStereo: boolean;
  phonemes: FramePhoneme[];
  volume: number[];
  volumeScale: number;
}

/**
 * ã‚¨ãƒ³ã‚¸ãƒ³è‡ªä½“ã«é–¢ã™ã‚‹æƒ…å ±
 */
export interface EngineManifest {
  brand_name: string;
  default_sampling_rate: number;
  dependency_licenses: LicenseInfo[];
  frame_rate: number;
  icon: string;
  manifest_version: string;
  name: string;
  supported_features: SupportedFeatures;
  supported_vvlib_manifest_version?: string;
  terms_of_service: string;
  update_infos: UpdateInfo[];
  url: string;
  uuid: string;
}

/**
 * ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å¯èƒ½ãªéŸ³å£°ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®æƒ…å ±
 */
export interface DownloadableLibraryInfo {
  bytes: number;
  download_url: string;
  name: string;
  speakers: LibrarySpeaker[];
  uuid: string;
  version: string;
}

/**
 * CORSã®è¨±å¯ãƒ¢ãƒ¼ãƒ‰
 */
export type CorsPolicyMode = typeof CorsPolicyMode[keyof typeof CorsPolicyMode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CorsPolicyMode = {
  all: 'all',
  localapps: 'localapps',
} as const;

export interface BodySingFrameVolumeSingFrameVolumePost {
  frame_audio_query: FrameAudioQuery;
  score: Score;
}

export interface BodySettingPostSettingPost {
  allow_origin?: string;
  cors_policy_mode: CorsPolicyMode;
}

/**
 * ã‚¢ã‚¯ã‚»ãƒ³ãƒˆå¥ã”ã¨ã®æƒ…å ±
 */
export interface AccentPhrase {
  accent: number;
  is_interrogative?: boolean;
  moras: Mora[];
  pause_mora?: Mora;
}

/**
 * éŸ³å£°åˆæˆç”¨ã®ã‚¯ã‚¨ãƒª
 */
export interface AudioQuery {
  accent_phrases: AccentPhrase[];
  intonationScale: number;
  kana?: string;
  outputSamplingRate: number;
  outputStereo: boolean;
  pitchScale: number;
  postPhonemeLength: number;
  prePhonemeLength: number;
  speedScale: number;
  volumeScale: number;
}





/**
 * éŸ³å£°åˆæˆç”¨ã®ã‚¯ã‚¨ãƒªã®åˆæœŸå€¤ã‚’å¾—ã¾ã™ã€‚ã“ã“ã§å¾—ã‚‰ã‚ŒãŸã‚¯ã‚¨ãƒªã¯ãã®ã¾ã¾éŸ³å£°åˆæˆã«åˆ©ç”¨ã§ãã¾ã™ã€‚å„å€¤ã®æ„å‘³ã¯`Schemas`ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚
 * @summary éŸ³å£°åˆæˆç”¨ã®ã‚¯ã‚¨ãƒªã‚’ä½œæˆã™ã‚‹
 */
export const audioQueryAudioQueryPost = (
    params: AudioQueryAudioQueryPostParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AudioQuery>> => {
    
    return axios.default.post(
      `http://localhost:50021/audio_query`,undefined,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getAudioQueryAudioQueryPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof audioQueryAudioQueryPost>>, TError,{params: AudioQueryAudioQueryPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof audioQueryAudioQueryPost>>, TError,{params: AudioQueryAudioQueryPostParams}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof audioQueryAudioQueryPost>>, {params: AudioQueryAudioQueryPostParams}> = (props) => {
          const {params} = props ?? {};

          return  audioQueryAudioQueryPost(params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AudioQueryAudioQueryPostMutationResult = NonNullable<Awaited<ReturnType<typeof audioQueryAudioQueryPost>>>
    
    export type AudioQueryAudioQueryPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary éŸ³å£°åˆæˆç”¨ã®ã‚¯ã‚¨ãƒªã‚’ä½œæˆã™ã‚‹
 */
export const useAudioQueryAudioQueryPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof audioQueryAudioQueryPost>>, TError,{params: AudioQueryAudioQueryPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof audioQueryAudioQueryPost>>,
        TError,
        {params: AudioQueryAudioQueryPostParams},
        TContext
      > => {

      const mutationOptions = getAudioQueryAudioQueryPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * éŸ³å£°åˆæˆç”¨ã®ã‚¯ã‚¨ãƒªã®åˆæœŸå€¤ã‚’å¾—ã¾ã™ã€‚ã“ã“ã§å¾—ã‚‰ã‚ŒãŸã‚¯ã‚¨ãƒªã¯ãã®ã¾ã¾éŸ³å£°åˆæˆã«åˆ©ç”¨ã§ãã¾ã™ã€‚å„å€¤ã®æ„å‘³ã¯`Schemas`ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚
 * @summary éŸ³å£°åˆæˆç”¨ã®ã‚¯ã‚¨ãƒªã‚’ãƒ—ãƒªã‚»ãƒƒãƒˆã‚’ç”¨ã„ã¦ä½œæˆã™ã‚‹
 */
export const audioQueryFromPresetAudioQueryFromPresetPost = (
    params: AudioQueryFromPresetAudioQueryFromPresetPostParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AudioQuery>> => {
    
    return axios.default.post(
      `http://localhost:50021/audio_query_from_preset`,undefined,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getAudioQueryFromPresetAudioQueryFromPresetPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof audioQueryFromPresetAudioQueryFromPresetPost>>, TError,{params: AudioQueryFromPresetAudioQueryFromPresetPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof audioQueryFromPresetAudioQueryFromPresetPost>>, TError,{params: AudioQueryFromPresetAudioQueryFromPresetPostParams}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof audioQueryFromPresetAudioQueryFromPresetPost>>, {params: AudioQueryFromPresetAudioQueryFromPresetPostParams}> = (props) => {
          const {params} = props ?? {};

          return  audioQueryFromPresetAudioQueryFromPresetPost(params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AudioQueryFromPresetAudioQueryFromPresetPostMutationResult = NonNullable<Awaited<ReturnType<typeof audioQueryFromPresetAudioQueryFromPresetPost>>>
    
    export type AudioQueryFromPresetAudioQueryFromPresetPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary éŸ³å£°åˆæˆç”¨ã®ã‚¯ã‚¨ãƒªã‚’ãƒ—ãƒªã‚»ãƒƒãƒˆã‚’ç”¨ã„ã¦ä½œæˆã™ã‚‹
 */
export const useAudioQueryFromPresetAudioQueryFromPresetPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof audioQueryFromPresetAudioQueryFromPresetPost>>, TError,{params: AudioQueryFromPresetAudioQueryFromPresetPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof audioQueryFromPresetAudioQueryFromPresetPost>>,
        TError,
        {params: AudioQueryFromPresetAudioQueryFromPresetPostParams},
        TContext
      > => {

      const mutationOptions = getAudioQueryFromPresetAudioQueryFromPresetPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰ã‚¢ã‚¯ã‚»ãƒ³ãƒˆå¥ã‚’å¾—ã¾ã™ã€‚
is_kanaãŒ`true`ã®ã¨ãã€ãƒ†ã‚­ã‚¹ãƒˆã¯æ¬¡ã®AquesTalk é¢¨è¨˜æ³•ã§è§£é‡ˆã•ã‚Œã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯`false`ã§ã™ã€‚
* å…¨ã¦ã®ã‚«ãƒŠã¯ã‚«ã‚¿ã‚«ãƒŠã§è¨˜è¿°ã•ã‚Œã‚‹
* ã‚¢ã‚¯ã‚»ãƒ³ãƒˆå¥ã¯`/`ã¾ãŸã¯`ã€`ã§åŒºåˆ‡ã‚‹ã€‚`ã€`ã§åŒºåˆ‡ã£ãŸå ´åˆã«é™ã‚Šç„¡éŸ³åŒºé–“ãŒæŒ¿å…¥ã•ã‚Œã‚‹ã€‚
* ã‚«ãƒŠã®æ‰‹å‰ã«`_`ã‚’å…¥ã‚Œã‚‹ã¨ãã®ã‚«ãƒŠã¯ç„¡å£°åŒ–ã•ã‚Œã‚‹
* ã‚¢ã‚¯ã‚»ãƒ³ãƒˆä½ç½®ã‚’`'`ã§æŒ‡å®šã™ã‚‹ã€‚å…¨ã¦ã®ã‚¢ã‚¯ã‚»ãƒ³ãƒˆå¥ã«ã¯ã‚¢ã‚¯ã‚»ãƒ³ãƒˆä½ç½®ã‚’1ã¤æŒ‡å®šã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚
* ã‚¢ã‚¯ã‚»ãƒ³ãƒˆå¥æœ«ã«`ï¼Ÿ`(å…¨è§’)ã‚’å…¥ã‚Œã‚‹ã“ã¨ã«ã‚ˆã‚Šç–‘å•æ–‡ã®ç™ºéŸ³ãŒã§ãã‚‹ã€‚
 * @summary ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰ã‚¢ã‚¯ã‚»ãƒ³ãƒˆå¥ã‚’å¾—ã‚‹
 */
export const accentPhrasesAccentPhrasesPost = (
    params: AccentPhrasesAccentPhrasesPostParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AccentPhrase[]>> => {
    
    return axios.default.post(
      `http://localhost:50021/accent_phrases`,undefined,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getAccentPhrasesAccentPhrasesPostMutationOptions = <TError = AxiosError<ParseKanaBadRequest | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof accentPhrasesAccentPhrasesPost>>, TError,{params: AccentPhrasesAccentPhrasesPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof accentPhrasesAccentPhrasesPost>>, TError,{params: AccentPhrasesAccentPhrasesPostParams}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof accentPhrasesAccentPhrasesPost>>, {params: AccentPhrasesAccentPhrasesPostParams}> = (props) => {
          const {params} = props ?? {};

          return  accentPhrasesAccentPhrasesPost(params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AccentPhrasesAccentPhrasesPostMutationResult = NonNullable<Awaited<ReturnType<typeof accentPhrasesAccentPhrasesPost>>>
    
    export type AccentPhrasesAccentPhrasesPostMutationError = AxiosError<ParseKanaBadRequest | HTTPValidationError>

    /**
 * @summary ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰ã‚¢ã‚¯ã‚»ãƒ³ãƒˆå¥ã‚’å¾—ã‚‹
 */
export const useAccentPhrasesAccentPhrasesPost = <TError = AxiosError<ParseKanaBadRequest | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof accentPhrasesAccentPhrasesPost>>, TError,{params: AccentPhrasesAccentPhrasesPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof accentPhrasesAccentPhrasesPost>>,
        TError,
        {params: AccentPhrasesAccentPhrasesPostParams},
        TContext
      > => {

      const mutationOptions = getAccentPhrasesAccentPhrasesPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ã‚¢ã‚¯ã‚»ãƒ³ãƒˆå¥ã‹ã‚‰éŸ³é«˜ãƒ»éŸ³ç´ é•·ã‚’å¾—ã‚‹
 */
export const moraDataMoraDataPost = (
    accentPhrase: AccentPhrase[],
    params: MoraDataMoraDataPostParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AccentPhrase[]>> => {
    
    return axios.default.post(
      `http://localhost:50021/mora_data`,
      accentPhrase,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getMoraDataMoraDataPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof moraDataMoraDataPost>>, TError,{data: AccentPhrase[];params: MoraDataMoraDataPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof moraDataMoraDataPost>>, TError,{data: AccentPhrase[];params: MoraDataMoraDataPostParams}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof moraDataMoraDataPost>>, {data: AccentPhrase[];params: MoraDataMoraDataPostParams}> = (props) => {
          const {data,params} = props ?? {};

          return  moraDataMoraDataPost(data,params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type MoraDataMoraDataPostMutationResult = NonNullable<Awaited<ReturnType<typeof moraDataMoraDataPost>>>
    export type MoraDataMoraDataPostMutationBody = AccentPhrase[]
    export type MoraDataMoraDataPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary ã‚¢ã‚¯ã‚»ãƒ³ãƒˆå¥ã‹ã‚‰éŸ³é«˜ãƒ»éŸ³ç´ é•·ã‚’å¾—ã‚‹
 */
export const useMoraDataMoraDataPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof moraDataMoraDataPost>>, TError,{data: AccentPhrase[];params: MoraDataMoraDataPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof moraDataMoraDataPost>>,
        TError,
        {data: AccentPhrase[];params: MoraDataMoraDataPostParams},
        TContext
      > => {

      const mutationOptions = getMoraDataMoraDataPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ã‚¢ã‚¯ã‚»ãƒ³ãƒˆå¥ã‹ã‚‰éŸ³ç´ é•·ã‚’å¾—ã‚‹
 */
export const moraLengthMoraLengthPost = (
    accentPhrase: AccentPhrase[],
    params: MoraLengthMoraLengthPostParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AccentPhrase[]>> => {
    
    return axios.default.post(
      `http://localhost:50021/mora_length`,
      accentPhrase,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getMoraLengthMoraLengthPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof moraLengthMoraLengthPost>>, TError,{data: AccentPhrase[];params: MoraLengthMoraLengthPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof moraLengthMoraLengthPost>>, TError,{data: AccentPhrase[];params: MoraLengthMoraLengthPostParams}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof moraLengthMoraLengthPost>>, {data: AccentPhrase[];params: MoraLengthMoraLengthPostParams}> = (props) => {
          const {data,params} = props ?? {};

          return  moraLengthMoraLengthPost(data,params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type MoraLengthMoraLengthPostMutationResult = NonNullable<Awaited<ReturnType<typeof moraLengthMoraLengthPost>>>
    export type MoraLengthMoraLengthPostMutationBody = AccentPhrase[]
    export type MoraLengthMoraLengthPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary ã‚¢ã‚¯ã‚»ãƒ³ãƒˆå¥ã‹ã‚‰éŸ³ç´ é•·ã‚’å¾—ã‚‹
 */
export const useMoraLengthMoraLengthPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof moraLengthMoraLengthPost>>, TError,{data: AccentPhrase[];params: MoraLengthMoraLengthPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof moraLengthMoraLengthPost>>,
        TError,
        {data: AccentPhrase[];params: MoraLengthMoraLengthPostParams},
        TContext
      > => {

      const mutationOptions = getMoraLengthMoraLengthPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ã‚¢ã‚¯ã‚»ãƒ³ãƒˆå¥ã‹ã‚‰éŸ³é«˜ã‚’å¾—ã‚‹
 */
export const moraPitchMoraPitchPost = (
    accentPhrase: AccentPhrase[],
    params: MoraPitchMoraPitchPostParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AccentPhrase[]>> => {
    
    return axios.default.post(
      `http://localhost:50021/mora_pitch`,
      accentPhrase,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getMoraPitchMoraPitchPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof moraPitchMoraPitchPost>>, TError,{data: AccentPhrase[];params: MoraPitchMoraPitchPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof moraPitchMoraPitchPost>>, TError,{data: AccentPhrase[];params: MoraPitchMoraPitchPostParams}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof moraPitchMoraPitchPost>>, {data: AccentPhrase[];params: MoraPitchMoraPitchPostParams}> = (props) => {
          const {data,params} = props ?? {};

          return  moraPitchMoraPitchPost(data,params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type MoraPitchMoraPitchPostMutationResult = NonNullable<Awaited<ReturnType<typeof moraPitchMoraPitchPost>>>
    export type MoraPitchMoraPitchPostMutationBody = AccentPhrase[]
    export type MoraPitchMoraPitchPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary ã‚¢ã‚¯ã‚»ãƒ³ãƒˆå¥ã‹ã‚‰éŸ³é«˜ã‚’å¾—ã‚‹
 */
export const useMoraPitchMoraPitchPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof moraPitchMoraPitchPost>>, TError,{data: AccentPhrase[];params: MoraPitchMoraPitchPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof moraPitchMoraPitchPost>>,
        TError,
        {data: AccentPhrase[];params: MoraPitchMoraPitchPostParams},
        TContext
      > => {

      const mutationOptions = getMoraPitchMoraPitchPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary éŸ³å£°åˆæˆã™ã‚‹
 */
export const synthesisSynthesisPost = (
    audioQuery: AudioQuery,
    params: SynthesisSynthesisPostParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Blob>> => {
    
    return axios.default.post(
      `http://localhost:50021/synthesis`,
      audioQuery,{
        responseType: 'blob',
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getSynthesisSynthesisPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof synthesisSynthesisPost>>, TError,{data: AudioQuery;params: SynthesisSynthesisPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof synthesisSynthesisPost>>, TError,{data: AudioQuery;params: SynthesisSynthesisPostParams}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof synthesisSynthesisPost>>, {data: AudioQuery;params: SynthesisSynthesisPostParams}> = (props) => {
          const {data,params} = props ?? {};

          return  synthesisSynthesisPost(data,params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SynthesisSynthesisPostMutationResult = NonNullable<Awaited<ReturnType<typeof synthesisSynthesisPost>>>
    export type SynthesisSynthesisPostMutationBody = AudioQuery
    export type SynthesisSynthesisPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary éŸ³å£°åˆæˆã™ã‚‹
 */
export const useSynthesisSynthesisPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof synthesisSynthesisPost>>, TError,{data: AudioQuery;params: SynthesisSynthesisPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof synthesisSynthesisPost>>,
        TError,
        {data: AudioQuery;params: SynthesisSynthesisPostParams},
        TContext
      > => {

      const mutationOptions = getSynthesisSynthesisPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary éŸ³å£°åˆæˆã™ã‚‹ï¼ˆã‚­ãƒ£ãƒ³ã‚»ãƒ«å¯èƒ½ï¼‰
 */
export const cancellableSynthesisCancellableSynthesisPost = (
    audioQuery: AudioQuery,
    params: CancellableSynthesisCancellableSynthesisPostParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Blob>> => {
    
    return axios.default.post(
      `http://localhost:50021/cancellable_synthesis`,
      audioQuery,{
        responseType: 'blob',
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getCancellableSynthesisCancellableSynthesisPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cancellableSynthesisCancellableSynthesisPost>>, TError,{data: AudioQuery;params: CancellableSynthesisCancellableSynthesisPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof cancellableSynthesisCancellableSynthesisPost>>, TError,{data: AudioQuery;params: CancellableSynthesisCancellableSynthesisPostParams}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof cancellableSynthesisCancellableSynthesisPost>>, {data: AudioQuery;params: CancellableSynthesisCancellableSynthesisPostParams}> = (props) => {
          const {data,params} = props ?? {};

          return  cancellableSynthesisCancellableSynthesisPost(data,params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CancellableSynthesisCancellableSynthesisPostMutationResult = NonNullable<Awaited<ReturnType<typeof cancellableSynthesisCancellableSynthesisPost>>>
    export type CancellableSynthesisCancellableSynthesisPostMutationBody = AudioQuery
    export type CancellableSynthesisCancellableSynthesisPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary éŸ³å£°åˆæˆã™ã‚‹ï¼ˆã‚­ãƒ£ãƒ³ã‚»ãƒ«å¯èƒ½ï¼‰
 */
export const useCancellableSynthesisCancellableSynthesisPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cancellableSynthesisCancellableSynthesisPost>>, TError,{data: AudioQuery;params: CancellableSynthesisCancellableSynthesisPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof cancellableSynthesisCancellableSynthesisPost>>,
        TError,
        {data: AudioQuery;params: CancellableSynthesisCancellableSynthesisPostParams},
        TContext
      > => {

      const mutationOptions = getCancellableSynthesisCancellableSynthesisPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary è¤‡æ•°ã¾ã¨ã‚ã¦éŸ³å£°åˆæˆã™ã‚‹
 */
export const multiSynthesisMultiSynthesisPost = (
    audioQuery: AudioQuery[],
    params: MultiSynthesisMultiSynthesisPostParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Blob>> => {
    
    return axios.default.post(
      `http://localhost:50021/multi_synthesis`,
      audioQuery,{
        responseType: 'blob',
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getMultiSynthesisMultiSynthesisPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof multiSynthesisMultiSynthesisPost>>, TError,{data: AudioQuery[];params: MultiSynthesisMultiSynthesisPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof multiSynthesisMultiSynthesisPost>>, TError,{data: AudioQuery[];params: MultiSynthesisMultiSynthesisPostParams}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof multiSynthesisMultiSynthesisPost>>, {data: AudioQuery[];params: MultiSynthesisMultiSynthesisPostParams}> = (props) => {
          const {data,params} = props ?? {};

          return  multiSynthesisMultiSynthesisPost(data,params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type MultiSynthesisMultiSynthesisPostMutationResult = NonNullable<Awaited<ReturnType<typeof multiSynthesisMultiSynthesisPost>>>
    export type MultiSynthesisMultiSynthesisPostMutationBody = AudioQuery[]
    export type MultiSynthesisMultiSynthesisPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary è¤‡æ•°ã¾ã¨ã‚ã¦éŸ³å£°åˆæˆã™ã‚‹
 */
export const useMultiSynthesisMultiSynthesisPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof multiSynthesisMultiSynthesisPost>>, TError,{data: AudioQuery[];params: MultiSynthesisMultiSynthesisPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof multiSynthesisMultiSynthesisPost>>,
        TError,
        {data: AudioQuery[];params: MultiSynthesisMultiSynthesisPostParams},
        TContext
      > => {

      const mutationOptions = getMultiSynthesisMultiSynthesisPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * æ­Œå”±éŸ³å£°åˆæˆç”¨ã®ã‚¯ã‚¨ãƒªã®åˆæœŸå€¤ã‚’å¾—ã¾ã™ã€‚ã“ã“ã§å¾—ã‚‰ã‚ŒãŸã‚¯ã‚¨ãƒªã¯ãã®ã¾ã¾æ­Œå”±éŸ³å£°åˆæˆã«åˆ©ç”¨ã§ãã¾ã™ã€‚å„å€¤ã®æ„å‘³ã¯`Schemas`ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚
 * @summary æ­Œå”±éŸ³å£°åˆæˆç”¨ã®ã‚¯ã‚¨ãƒªã‚’ä½œæˆã™ã‚‹
 */
export const singFrameAudioQuerySingFrameAudioQueryPost = (
    score: Score,
    params: SingFrameAudioQuerySingFrameAudioQueryPostParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<FrameAudioQuery>> => {
    
    return axios.default.post(
      `http://localhost:50021/sing_frame_audio_query`,
      score,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getSingFrameAudioQuerySingFrameAudioQueryPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof singFrameAudioQuerySingFrameAudioQueryPost>>, TError,{data: Score;params: SingFrameAudioQuerySingFrameAudioQueryPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof singFrameAudioQuerySingFrameAudioQueryPost>>, TError,{data: Score;params: SingFrameAudioQuerySingFrameAudioQueryPostParams}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof singFrameAudioQuerySingFrameAudioQueryPost>>, {data: Score;params: SingFrameAudioQuerySingFrameAudioQueryPostParams}> = (props) => {
          const {data,params} = props ?? {};

          return  singFrameAudioQuerySingFrameAudioQueryPost(data,params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SingFrameAudioQuerySingFrameAudioQueryPostMutationResult = NonNullable<Awaited<ReturnType<typeof singFrameAudioQuerySingFrameAudioQueryPost>>>
    export type SingFrameAudioQuerySingFrameAudioQueryPostMutationBody = Score
    export type SingFrameAudioQuerySingFrameAudioQueryPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary æ­Œå”±éŸ³å£°åˆæˆç”¨ã®ã‚¯ã‚¨ãƒªã‚’ä½œæˆã™ã‚‹
 */
export const useSingFrameAudioQuerySingFrameAudioQueryPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof singFrameAudioQuerySingFrameAudioQueryPost>>, TError,{data: Score;params: SingFrameAudioQuerySingFrameAudioQueryPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof singFrameAudioQuerySingFrameAudioQueryPost>>,
        TError,
        {data: Score;params: SingFrameAudioQuerySingFrameAudioQueryPostParams},
        TContext
      > => {

      const mutationOptions = getSingFrameAudioQuerySingFrameAudioQueryPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary ã‚¹ã‚³ã‚¢ãƒ»æ­Œå”±éŸ³å£°åˆæˆç”¨ã®ã‚¯ã‚¨ãƒªã‹ã‚‰ãƒ•ãƒ¬ãƒ¼ãƒ ã”ã¨ã®éŸ³é‡ã‚’å¾—ã‚‹
 */
export const singFrameVolumeSingFrameVolumePost = (
    bodySingFrameVolumeSingFrameVolumePost: BodySingFrameVolumeSingFrameVolumePost,
    params: SingFrameVolumeSingFrameVolumePostParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<number[]>> => {
    
    return axios.default.post(
      `http://localhost:50021/sing_frame_volume`,
      bodySingFrameVolumeSingFrameVolumePost,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getSingFrameVolumeSingFrameVolumePostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof singFrameVolumeSingFrameVolumePost>>, TError,{data: BodySingFrameVolumeSingFrameVolumePost;params: SingFrameVolumeSingFrameVolumePostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof singFrameVolumeSingFrameVolumePost>>, TError,{data: BodySingFrameVolumeSingFrameVolumePost;params: SingFrameVolumeSingFrameVolumePostParams}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof singFrameVolumeSingFrameVolumePost>>, {data: BodySingFrameVolumeSingFrameVolumePost;params: SingFrameVolumeSingFrameVolumePostParams}> = (props) => {
          const {data,params} = props ?? {};

          return  singFrameVolumeSingFrameVolumePost(data,params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SingFrameVolumeSingFrameVolumePostMutationResult = NonNullable<Awaited<ReturnType<typeof singFrameVolumeSingFrameVolumePost>>>
    export type SingFrameVolumeSingFrameVolumePostMutationBody = BodySingFrameVolumeSingFrameVolumePost
    export type SingFrameVolumeSingFrameVolumePostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary ã‚¹ã‚³ã‚¢ãƒ»æ­Œå”±éŸ³å£°åˆæˆç”¨ã®ã‚¯ã‚¨ãƒªã‹ã‚‰ãƒ•ãƒ¬ãƒ¼ãƒ ã”ã¨ã®éŸ³é‡ã‚’å¾—ã‚‹
 */
export const useSingFrameVolumeSingFrameVolumePost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof singFrameVolumeSingFrameVolumePost>>, TError,{data: BodySingFrameVolumeSingFrameVolumePost;params: SingFrameVolumeSingFrameVolumePostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof singFrameVolumeSingFrameVolumePost>>,
        TError,
        {data: BodySingFrameVolumeSingFrameVolumePost;params: SingFrameVolumeSingFrameVolumePostParams},
        TContext
      > => {

      const mutationOptions = getSingFrameVolumeSingFrameVolumePostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * æ­Œå”±éŸ³å£°åˆæˆã‚’è¡Œã„ã¾ã™ã€‚
 * @summary Frame Synthesis
 */
export const frameSynthesisFrameSynthesisPost = (
    frameAudioQuery: FrameAudioQuery,
    params: FrameSynthesisFrameSynthesisPostParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Blob>> => {
    
    return axios.default.post(
      `http://localhost:50021/frame_synthesis`,
      frameAudioQuery,{
        responseType: 'blob',
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getFrameSynthesisFrameSynthesisPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof frameSynthesisFrameSynthesisPost>>, TError,{data: FrameAudioQuery;params: FrameSynthesisFrameSynthesisPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof frameSynthesisFrameSynthesisPost>>, TError,{data: FrameAudioQuery;params: FrameSynthesisFrameSynthesisPostParams}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof frameSynthesisFrameSynthesisPost>>, {data: FrameAudioQuery;params: FrameSynthesisFrameSynthesisPostParams}> = (props) => {
          const {data,params} = props ?? {};

          return  frameSynthesisFrameSynthesisPost(data,params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type FrameSynthesisFrameSynthesisPostMutationResult = NonNullable<Awaited<ReturnType<typeof frameSynthesisFrameSynthesisPost>>>
    export type FrameSynthesisFrameSynthesisPostMutationBody = FrameAudioQuery
    export type FrameSynthesisFrameSynthesisPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Frame Synthesis
 */
export const useFrameSynthesisFrameSynthesisPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof frameSynthesisFrameSynthesisPost>>, TError,{data: FrameAudioQuery;params: FrameSynthesisFrameSynthesisPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof frameSynthesisFrameSynthesisPost>>,
        TError,
        {data: FrameAudioQuery;params: FrameSynthesisFrameSynthesisPostParams},
        TContext
      > => {

      const mutationOptions = getFrameSynthesisFrameSynthesisPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * base64ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸwavãƒ‡ãƒ¼ã‚¿ã‚’ä¸€çºã‚ã«ã—ã€wavãƒ•ã‚¡ã‚¤ãƒ«ã§è¿”ã—ã¾ã™ã€‚
 * @summary base64ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸè¤‡æ•°ã®wavãƒ‡ãƒ¼ã‚¿ã‚’ä¸€ã¤ã«çµåˆã™ã‚‹
 */
export const connectWavesConnectWavesPost = (
    connectWavesConnectWavesPostBody: string[], options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Blob>> => {
    
    return axios.default.post(
      `http://localhost:50021/connect_waves`,
      connectWavesConnectWavesPostBody,{
        responseType: 'blob',
    ...options,}
    );
  }



export const getConnectWavesConnectWavesPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof connectWavesConnectWavesPost>>, TError,{data: string[]}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof connectWavesConnectWavesPost>>, TError,{data: string[]}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof connectWavesConnectWavesPost>>, {data: string[]}> = (props) => {
          const {data} = props ?? {};

          return  connectWavesConnectWavesPost(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ConnectWavesConnectWavesPostMutationResult = NonNullable<Awaited<ReturnType<typeof connectWavesConnectWavesPost>>>
    export type ConnectWavesConnectWavesPostMutationBody = string[]
    export type ConnectWavesConnectWavesPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary base64ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸè¤‡æ•°ã®wavãƒ‡ãƒ¼ã‚¿ã‚’ä¸€ã¤ã«çµåˆã™ã‚‹
 */
export const useConnectWavesConnectWavesPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof connectWavesConnectWavesPost>>, TError,{data: string[]}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof connectWavesConnectWavesPost>>,
        TError,
        {data: string[]},
        TContext
      > => {

      const mutationOptions = getConnectWavesConnectWavesPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * ãƒ†ã‚­ã‚¹ãƒˆãŒAquesTalk é¢¨è¨˜æ³•ã«å¾“ã£ã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’åˆ¤å®šã—ã¾ã™ã€‚
å¾“ã£ã¦ã„ãªã„å ´åˆã¯ã‚¨ãƒ©ãƒ¼ãŒè¿”ã‚Šã¾ã™ã€‚
 * @summary ãƒ†ã‚­ã‚¹ãƒˆãŒAquesTalk é¢¨è¨˜æ³•ã«å¾“ã£ã¦ã„ã‚‹ã‹åˆ¤å®šã™ã‚‹
 */
export const validateKanaValidateKanaPost = (
    params: ValidateKanaValidateKanaPostParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<boolean>> => {
    
    return axios.default.post(
      `http://localhost:50021/validate_kana`,undefined,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getValidateKanaValidateKanaPostMutationOptions = <TError = AxiosError<ParseKanaBadRequest | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof validateKanaValidateKanaPost>>, TError,{params: ValidateKanaValidateKanaPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof validateKanaValidateKanaPost>>, TError,{params: ValidateKanaValidateKanaPostParams}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof validateKanaValidateKanaPost>>, {params: ValidateKanaValidateKanaPostParams}> = (props) => {
          const {params} = props ?? {};

          return  validateKanaValidateKanaPost(params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ValidateKanaValidateKanaPostMutationResult = NonNullable<Awaited<ReturnType<typeof validateKanaValidateKanaPost>>>
    
    export type ValidateKanaValidateKanaPostMutationError = AxiosError<ParseKanaBadRequest | HTTPValidationError>

    /**
 * @summary ãƒ†ã‚­ã‚¹ãƒˆãŒAquesTalk é¢¨è¨˜æ³•ã«å¾“ã£ã¦ã„ã‚‹ã‹åˆ¤å®šã™ã‚‹
 */
export const useValidateKanaValidateKanaPost = <TError = AxiosError<ParseKanaBadRequest | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof validateKanaValidateKanaPost>>, TError,{params: ValidateKanaValidateKanaPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof validateKanaValidateKanaPost>>,
        TError,
        {params: ValidateKanaValidateKanaPostParams},
        TContext
      > => {

      const mutationOptions = getValidateKanaValidateKanaPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * æŒ‡å®šã•ã‚ŒãŸãƒ™ãƒ¼ã‚¹ã‚¹ã‚¿ã‚¤ãƒ«ã«å¯¾ã—ã¦ã‚¨ãƒ³ã‚¸ãƒ³å†…ã®å„è©±è€…ãŒãƒ¢ãƒ¼ãƒ•ã‚£ãƒ³ã‚°æ©Ÿèƒ½ã‚’åˆ©ç”¨å¯èƒ½ã‹è¿”ã—ã¾ã™ã€‚
ãƒ¢ãƒ¼ãƒ•ã‚£ãƒ³ã‚°ã®è¨±å¯/ç¦æ­¢ã¯`/speakers`ã®`speaker.supported_features.synthesis_morphing`ã«è¨˜è¼‰ã•ã‚Œã¦ã„ã¾ã™ã€‚
ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ã€ãƒ¢ãƒ¼ãƒ•ã‚£ãƒ³ã‚°ãŒè¨±å¯ã•ã‚Œã¦ã„ã‚‹ã¨ã¿ãªã—ã¾ã™ã€‚
è¿”ã‚Šå€¤ã®ã‚¹ã‚¿ã‚¤ãƒ«IDã¯stringå‹ãªã®ã§æ³¨æ„ã€‚
 * @summary æŒ‡å®šã—ãŸã‚¹ã‚¿ã‚¤ãƒ«ã«å¯¾ã—ã¦ã‚¨ãƒ³ã‚¸ãƒ³å†…ã®è©±è€…ãŒãƒ¢ãƒ¼ãƒ•ã‚£ãƒ³ã‚°ãŒå¯èƒ½ã‹åˆ¤å®šã™ã‚‹
 */
export const morphableTargetsMorphableTargetsPost = (
    morphableTargetsMorphableTargetsPostBody: number[],
    params?: MorphableTargetsMorphableTargetsPostParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MorphableTargetsMorphableTargetsPost200Item[]>> => {
    
    return axios.default.post(
      `http://localhost:50021/morphable_targets`,
      morphableTargetsMorphableTargetsPostBody,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getMorphableTargetsMorphableTargetsPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof morphableTargetsMorphableTargetsPost>>, TError,{data: number[];params?: MorphableTargetsMorphableTargetsPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof morphableTargetsMorphableTargetsPost>>, TError,{data: number[];params?: MorphableTargetsMorphableTargetsPostParams}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof morphableTargetsMorphableTargetsPost>>, {data: number[];params?: MorphableTargetsMorphableTargetsPostParams}> = (props) => {
          const {data,params} = props ?? {};

          return  morphableTargetsMorphableTargetsPost(data,params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type MorphableTargetsMorphableTargetsPostMutationResult = NonNullable<Awaited<ReturnType<typeof morphableTargetsMorphableTargetsPost>>>
    export type MorphableTargetsMorphableTargetsPostMutationBody = number[]
    export type MorphableTargetsMorphableTargetsPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary æŒ‡å®šã—ãŸã‚¹ã‚¿ã‚¤ãƒ«ã«å¯¾ã—ã¦ã‚¨ãƒ³ã‚¸ãƒ³å†…ã®è©±è€…ãŒãƒ¢ãƒ¼ãƒ•ã‚£ãƒ³ã‚°ãŒå¯èƒ½ã‹åˆ¤å®šã™ã‚‹
 */
export const useMorphableTargetsMorphableTargetsPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof morphableTargetsMorphableTargetsPost>>, TError,{data: number[];params?: MorphableTargetsMorphableTargetsPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof morphableTargetsMorphableTargetsPost>>,
        TError,
        {data: number[];params?: MorphableTargetsMorphableTargetsPostParams},
        TContext
      > => {

      const mutationOptions = getMorphableTargetsMorphableTargetsPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * æŒ‡å®šã•ã‚ŒãŸ2ç¨®é¡ã®ã‚¹ã‚¿ã‚¤ãƒ«ã§éŸ³å£°ã‚’åˆæˆã€æŒ‡å®šã—ãŸå‰²åˆã§ãƒ¢ãƒ¼ãƒ•ã‚£ãƒ³ã‚°ã—ãŸéŸ³å£°ã‚’å¾—ã¾ã™ã€‚
ãƒ¢ãƒ¼ãƒ•ã‚£ãƒ³ã‚°ã®å‰²åˆã¯`morph_rate`ã§æŒ‡å®šã§ãã€0.0ã§ãƒ™ãƒ¼ã‚¹ã®ã‚¹ã‚¿ã‚¤ãƒ«ã€1.0ã§ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®ã‚¹ã‚¿ã‚¤ãƒ«ã«è¿‘ã¥ãã¾ã™ã€‚
 * @summary 2ç¨®é¡ã®ã‚¹ã‚¿ã‚¤ãƒ«ã§ãƒ¢ãƒ¼ãƒ•ã‚£ãƒ³ã‚°ã—ãŸéŸ³å£°ã‚’åˆæˆã™ã‚‹
 */
export const synthesisMorphingSynthesisMorphingPost = (
    audioQuery: AudioQuery,
    params: SynthesisMorphingSynthesisMorphingPostParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Blob>> => {
    
    return axios.default.post(
      `http://localhost:50021/synthesis_morphing`,
      audioQuery,{
        responseType: 'blob',
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getSynthesisMorphingSynthesisMorphingPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof synthesisMorphingSynthesisMorphingPost>>, TError,{data: AudioQuery;params: SynthesisMorphingSynthesisMorphingPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof synthesisMorphingSynthesisMorphingPost>>, TError,{data: AudioQuery;params: SynthesisMorphingSynthesisMorphingPostParams}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof synthesisMorphingSynthesisMorphingPost>>, {data: AudioQuery;params: SynthesisMorphingSynthesisMorphingPostParams}> = (props) => {
          const {data,params} = props ?? {};

          return  synthesisMorphingSynthesisMorphingPost(data,params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SynthesisMorphingSynthesisMorphingPostMutationResult = NonNullable<Awaited<ReturnType<typeof synthesisMorphingSynthesisMorphingPost>>>
    export type SynthesisMorphingSynthesisMorphingPostMutationBody = AudioQuery
    export type SynthesisMorphingSynthesisMorphingPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary 2ç¨®é¡ã®ã‚¹ã‚¿ã‚¤ãƒ«ã§ãƒ¢ãƒ¼ãƒ•ã‚£ãƒ³ã‚°ã—ãŸéŸ³å£°ã‚’åˆæˆã™ã‚‹
 */
export const useSynthesisMorphingSynthesisMorphingPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof synthesisMorphingSynthesisMorphingPost>>, TError,{data: AudioQuery;params: SynthesisMorphingSynthesisMorphingPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof synthesisMorphingSynthesisMorphingPost>>,
        TError,
        {data: AudioQuery;params: SynthesisMorphingSynthesisMorphingPostParams},
        TContext
      > => {

      const mutationOptions = getSynthesisMorphingSynthesisMorphingPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * ã‚¨ãƒ³ã‚¸ãƒ³ãŒä¿æŒã—ã¦ã„ã‚‹ãƒ—ãƒªã‚»ãƒƒãƒˆã®è¨­å®šã‚’è¿”ã—ã¾ã™
 * @summary Get Presets
 */
export const getPresetsPresetsGet = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Preset[]>> => {
    
    return axios.default.get(
      `http://localhost:50021/presets`,options
    );
  }


export const getGetPresetsPresetsGetQueryKey = () => {
    return [`http://localhost:50021/presets`] as const;
    }

    
export const getGetPresetsPresetsGetQueryOptions = <TData = Awaited<ReturnType<typeof getPresetsPresetsGet>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getPresetsPresetsGet>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPresetsPresetsGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPresetsPresetsGet>>> = ({ signal }) => getPresetsPresetsGet({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPresetsPresetsGet>>, TError, TData> & { queryKey: QueryKey }
}

export type GetPresetsPresetsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getPresetsPresetsGet>>>
export type GetPresetsPresetsGetQueryError = AxiosError<unknown>

/**
 * @summary Get Presets
 */
export const useGetPresetsPresetsGet = <TData = Awaited<ReturnType<typeof getPresetsPresetsGet>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getPresetsPresetsGet>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetPresetsPresetsGetQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * æ–°ã—ã„ãƒ—ãƒªã‚»ãƒƒãƒˆã‚’è¿½åŠ ã—ã¾ã™
 * @summary Add Preset
 */
export const addPresetAddPresetPost = (
    preset: Preset, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<number>> => {
    
    return axios.default.post(
      `http://localhost:50021/add_preset`,
      preset,options
    );
  }



export const getAddPresetAddPresetPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addPresetAddPresetPost>>, TError,{data: Preset}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof addPresetAddPresetPost>>, TError,{data: Preset}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addPresetAddPresetPost>>, {data: Preset}> = (props) => {
          const {data} = props ?? {};

          return  addPresetAddPresetPost(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddPresetAddPresetPostMutationResult = NonNullable<Awaited<ReturnType<typeof addPresetAddPresetPost>>>
    export type AddPresetAddPresetPostMutationBody = Preset
    export type AddPresetAddPresetPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Add Preset
 */
export const useAddPresetAddPresetPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addPresetAddPresetPost>>, TError,{data: Preset}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof addPresetAddPresetPost>>,
        TError,
        {data: Preset},
        TContext
      > => {

      const mutationOptions = getAddPresetAddPresetPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * æ—¢å­˜ã®ãƒ—ãƒªã‚»ãƒƒãƒˆã‚’æ›´æ–°ã—ã¾ã™
 * @summary Update Preset
 */
export const updatePresetUpdatePresetPost = (
    preset: Preset, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<number>> => {
    
    return axios.default.post(
      `http://localhost:50021/update_preset`,
      preset,options
    );
  }



export const getUpdatePresetUpdatePresetPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePresetUpdatePresetPost>>, TError,{data: Preset}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updatePresetUpdatePresetPost>>, TError,{data: Preset}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatePresetUpdatePresetPost>>, {data: Preset}> = (props) => {
          const {data} = props ?? {};

          return  updatePresetUpdatePresetPost(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdatePresetUpdatePresetPostMutationResult = NonNullable<Awaited<ReturnType<typeof updatePresetUpdatePresetPost>>>
    export type UpdatePresetUpdatePresetPostMutationBody = Preset
    export type UpdatePresetUpdatePresetPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Update Preset
 */
export const useUpdatePresetUpdatePresetPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePresetUpdatePresetPost>>, TError,{data: Preset}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof updatePresetUpdatePresetPost>>,
        TError,
        {data: Preset},
        TContext
      > => {

      const mutationOptions = getUpdatePresetUpdatePresetPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * æ—¢å­˜ã®ãƒ—ãƒªã‚»ãƒƒãƒˆã‚’å‰Šé™¤ã—ã¾ã™
 * @summary Delete Preset
 */
export const deletePresetDeletePresetPost = (
    params: DeletePresetDeletePresetPostParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.default.post(
      `http://localhost:50021/delete_preset`,undefined,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getDeletePresetDeletePresetPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePresetDeletePresetPost>>, TError,{params: DeletePresetDeletePresetPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deletePresetDeletePresetPost>>, TError,{params: DeletePresetDeletePresetPostParams}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePresetDeletePresetPost>>, {params: DeletePresetDeletePresetPostParams}> = (props) => {
          const {params} = props ?? {};

          return  deletePresetDeletePresetPost(params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeletePresetDeletePresetPostMutationResult = NonNullable<Awaited<ReturnType<typeof deletePresetDeletePresetPost>>>
    
    export type DeletePresetDeletePresetPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Delete Preset
 */
export const useDeletePresetDeletePresetPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePresetDeletePresetPost>>, TError,{params: DeletePresetDeletePresetPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deletePresetDeletePresetPost>>,
        TError,
        {params: DeletePresetDeletePresetPostParams},
        TContext
      > => {

      const mutationOptions = getDeletePresetDeletePresetPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Version
 */
export const versionVersionGet = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    
    return axios.default.get(
      `http://localhost:50021/version`,options
    );
  }


export const getVersionVersionGetQueryKey = () => {
    return [`http://localhost:50021/version`] as const;
    }

    
export const getVersionVersionGetQueryOptions = <TData = Awaited<ReturnType<typeof versionVersionGet>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof versionVersionGet>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getVersionVersionGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof versionVersionGet>>> = ({ signal }) => versionVersionGet({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof versionVersionGet>>, TError, TData> & { queryKey: QueryKey }
}

export type VersionVersionGetQueryResult = NonNullable<Awaited<ReturnType<typeof versionVersionGet>>>
export type VersionVersionGetQueryError = AxiosError<unknown>

/**
 * @summary Version
 */
export const useVersionVersionGet = <TData = Awaited<ReturnType<typeof versionVersionGet>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof versionVersionGet>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getVersionVersionGetQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Core Versions
 */
export const coreVersionsCoreVersionsGet = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string[]>> => {
    
    return axios.default.get(
      `http://localhost:50021/core_versions`,options
    );
  }


export const getCoreVersionsCoreVersionsGetQueryKey = () => {
    return [`http://localhost:50021/core_versions`] as const;
    }

    
export const getCoreVersionsCoreVersionsGetQueryOptions = <TData = Awaited<ReturnType<typeof coreVersionsCoreVersionsGet>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof coreVersionsCoreVersionsGet>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCoreVersionsCoreVersionsGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof coreVersionsCoreVersionsGet>>> = ({ signal }) => coreVersionsCoreVersionsGet({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof coreVersionsCoreVersionsGet>>, TError, TData> & { queryKey: QueryKey }
}

export type CoreVersionsCoreVersionsGetQueryResult = NonNullable<Awaited<ReturnType<typeof coreVersionsCoreVersionsGet>>>
export type CoreVersionsCoreVersionsGetQueryError = AxiosError<unknown>

/**
 * @summary Core Versions
 */
export const useCoreVersionsCoreVersionsGet = <TData = Awaited<ReturnType<typeof coreVersionsCoreVersionsGet>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof coreVersionsCoreVersionsGet>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getCoreVersionsCoreVersionsGetQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Speakers
 */
export const speakersSpeakersGet = (
    params?: SpeakersSpeakersGetParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Speaker[]>> => {
    
    return axios.default.get(
      `http://localhost:50021/speakers`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getSpeakersSpeakersGetQueryKey = (params?: SpeakersSpeakersGetParams,) => {
    return [`http://localhost:50021/speakers`, ...(params ? [params]: [])] as const;
    }

    
export const getSpeakersSpeakersGetQueryOptions = <TData = Awaited<ReturnType<typeof speakersSpeakersGet>>, TError = AxiosError<HTTPValidationError>>(params?: SpeakersSpeakersGetParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof speakersSpeakersGet>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSpeakersSpeakersGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof speakersSpeakersGet>>> = ({ signal }) => speakersSpeakersGet(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof speakersSpeakersGet>>, TError, TData> & { queryKey: QueryKey }
}

export type SpeakersSpeakersGetQueryResult = NonNullable<Awaited<ReturnType<typeof speakersSpeakersGet>>>
export type SpeakersSpeakersGetQueryError = AxiosError<HTTPValidationError>

/**
 * @summary Speakers
 */
export const useSpeakersSpeakersGet = <TData = Awaited<ReturnType<typeof speakersSpeakersGet>>, TError = AxiosError<HTTPValidationError>>(
 params?: SpeakersSpeakersGetParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof speakersSpeakersGet>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getSpeakersSpeakersGetQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * æŒ‡å®šã•ã‚ŒãŸspeaker_uuidã«é–¢ã™ã‚‹æƒ…å ±ã‚’jsonå½¢å¼ã§è¿”ã—ã¾ã™ã€‚
ç”»åƒã‚„éŸ³å£°ã¯base64ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸã‚‚ã®ãŒè¿”ã•ã‚Œã¾ã™ã€‚
 * @summary Speaker Info
 */
export const speakerInfoSpeakerInfoGet = (
    params: SpeakerInfoSpeakerInfoGetParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SpeakerInfo>> => {
    
    return axios.default.get(
      `http://localhost:50021/speaker_info`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getSpeakerInfoSpeakerInfoGetQueryKey = (params: SpeakerInfoSpeakerInfoGetParams,) => {
    return [`http://localhost:50021/speaker_info`, ...(params ? [params]: [])] as const;
    }

    
export const getSpeakerInfoSpeakerInfoGetQueryOptions = <TData = Awaited<ReturnType<typeof speakerInfoSpeakerInfoGet>>, TError = AxiosError<HTTPValidationError>>(params: SpeakerInfoSpeakerInfoGetParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof speakerInfoSpeakerInfoGet>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSpeakerInfoSpeakerInfoGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof speakerInfoSpeakerInfoGet>>> = ({ signal }) => speakerInfoSpeakerInfoGet(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof speakerInfoSpeakerInfoGet>>, TError, TData> & { queryKey: QueryKey }
}

export type SpeakerInfoSpeakerInfoGetQueryResult = NonNullable<Awaited<ReturnType<typeof speakerInfoSpeakerInfoGet>>>
export type SpeakerInfoSpeakerInfoGetQueryError = AxiosError<HTTPValidationError>

/**
 * @summary Speaker Info
 */
export const useSpeakerInfoSpeakerInfoGet = <TData = Awaited<ReturnType<typeof speakerInfoSpeakerInfoGet>>, TError = AxiosError<HTTPValidationError>>(
 params: SpeakerInfoSpeakerInfoGetParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof speakerInfoSpeakerInfoGet>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getSpeakerInfoSpeakerInfoGetQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Singers
 */
export const singersSingersGet = (
    params?: SingersSingersGetParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Speaker[]>> => {
    
    return axios.default.get(
      `http://localhost:50021/singers`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getSingersSingersGetQueryKey = (params?: SingersSingersGetParams,) => {
    return [`http://localhost:50021/singers`, ...(params ? [params]: [])] as const;
    }

    
export const getSingersSingersGetQueryOptions = <TData = Awaited<ReturnType<typeof singersSingersGet>>, TError = AxiosError<HTTPValidationError>>(params?: SingersSingersGetParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof singersSingersGet>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSingersSingersGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof singersSingersGet>>> = ({ signal }) => singersSingersGet(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof singersSingersGet>>, TError, TData> & { queryKey: QueryKey }
}

export type SingersSingersGetQueryResult = NonNullable<Awaited<ReturnType<typeof singersSingersGet>>>
export type SingersSingersGetQueryError = AxiosError<HTTPValidationError>

/**
 * @summary Singers
 */
export const useSingersSingersGet = <TData = Awaited<ReturnType<typeof singersSingersGet>>, TError = AxiosError<HTTPValidationError>>(
 params?: SingersSingersGetParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof singersSingersGet>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getSingersSingersGetQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * æŒ‡å®šã•ã‚ŒãŸspeaker_uuidã«é–¢ã™ã‚‹æƒ…å ±ã‚’jsonå½¢å¼ã§è¿”ã—ã¾ã™ã€‚
ç”»åƒã‚„éŸ³å£°ã¯base64ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸã‚‚ã®ãŒè¿”ã•ã‚Œã¾ã™ã€‚
 * @summary Singer Info
 */
export const singerInfoSingerInfoGet = (
    params: SingerInfoSingerInfoGetParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SpeakerInfo>> => {
    
    return axios.default.get(
      `http://localhost:50021/singer_info`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getSingerInfoSingerInfoGetQueryKey = (params: SingerInfoSingerInfoGetParams,) => {
    return [`http://localhost:50021/singer_info`, ...(params ? [params]: [])] as const;
    }

    
export const getSingerInfoSingerInfoGetQueryOptions = <TData = Awaited<ReturnType<typeof singerInfoSingerInfoGet>>, TError = AxiosError<HTTPValidationError>>(params: SingerInfoSingerInfoGetParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof singerInfoSingerInfoGet>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSingerInfoSingerInfoGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof singerInfoSingerInfoGet>>> = ({ signal }) => singerInfoSingerInfoGet(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof singerInfoSingerInfoGet>>, TError, TData> & { queryKey: QueryKey }
}

export type SingerInfoSingerInfoGetQueryResult = NonNullable<Awaited<ReturnType<typeof singerInfoSingerInfoGet>>>
export type SingerInfoSingerInfoGetQueryError = AxiosError<HTTPValidationError>

/**
 * @summary Singer Info
 */
export const useSingerInfoSingerInfoGet = <TData = Awaited<ReturnType<typeof singerInfoSingerInfoGet>>, TError = AxiosError<HTTPValidationError>>(
 params: SingerInfoSingerInfoGetParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof singerInfoSingerInfoGet>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getSingerInfoSingerInfoGetQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å¯èƒ½ãªéŸ³å£°ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®æƒ…å ±ã‚’è¿”ã—ã¾ã™ã€‚
 * @summary Downloadable Libraries
 */
export const downloadableLibrariesDownloadableLibrariesGet = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<DownloadableLibraryInfo[]>> => {
    
    return axios.default.get(
      `http://localhost:50021/downloadable_libraries`,options
    );
  }


export const getDownloadableLibrariesDownloadableLibrariesGetQueryKey = () => {
    return [`http://localhost:50021/downloadable_libraries`] as const;
    }

    
export const getDownloadableLibrariesDownloadableLibrariesGetQueryOptions = <TData = Awaited<ReturnType<typeof downloadableLibrariesDownloadableLibrariesGet>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof downloadableLibrariesDownloadableLibrariesGet>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDownloadableLibrariesDownloadableLibrariesGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof downloadableLibrariesDownloadableLibrariesGet>>> = ({ signal }) => downloadableLibrariesDownloadableLibrariesGet({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof downloadableLibrariesDownloadableLibrariesGet>>, TError, TData> & { queryKey: QueryKey }
}

export type DownloadableLibrariesDownloadableLibrariesGetQueryResult = NonNullable<Awaited<ReturnType<typeof downloadableLibrariesDownloadableLibrariesGet>>>
export type DownloadableLibrariesDownloadableLibrariesGetQueryError = AxiosError<unknown>

/**
 * @summary Downloadable Libraries
 */
export const useDownloadableLibrariesDownloadableLibrariesGet = <TData = Awaited<ReturnType<typeof downloadableLibrariesDownloadableLibrariesGet>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof downloadableLibrariesDownloadableLibrariesGet>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getDownloadableLibrariesDownloadableLibrariesGetQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã—ãŸéŸ³å£°ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®æƒ…å ±ã‚’è¿”ã—ã¾ã™ã€‚
 * @summary Installed Libraries
 */
export const installedLibrariesInstalledLibrariesGet = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<InstalledLibrariesInstalledLibrariesGet200>> => {
    
    return axios.default.get(
      `http://localhost:50021/installed_libraries`,options
    );
  }


export const getInstalledLibrariesInstalledLibrariesGetQueryKey = () => {
    return [`http://localhost:50021/installed_libraries`] as const;
    }

    
export const getInstalledLibrariesInstalledLibrariesGetQueryOptions = <TData = Awaited<ReturnType<typeof installedLibrariesInstalledLibrariesGet>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof installedLibrariesInstalledLibrariesGet>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getInstalledLibrariesInstalledLibrariesGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof installedLibrariesInstalledLibrariesGet>>> = ({ signal }) => installedLibrariesInstalledLibrariesGet({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof installedLibrariesInstalledLibrariesGet>>, TError, TData> & { queryKey: QueryKey }
}

export type InstalledLibrariesInstalledLibrariesGetQueryResult = NonNullable<Awaited<ReturnType<typeof installedLibrariesInstalledLibrariesGet>>>
export type InstalledLibrariesInstalledLibrariesGetQueryError = AxiosError<unknown>

/**
 * @summary Installed Libraries
 */
export const useInstalledLibrariesInstalledLibrariesGet = <TData = Awaited<ReturnType<typeof installedLibrariesInstalledLibrariesGet>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof installedLibrariesInstalledLibrariesGet>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getInstalledLibrariesInstalledLibrariesGetQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * éŸ³å£°ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã—ã¾ã™ã€‚
éŸ³å£°ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ZIPãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒœãƒ‡ã‚£ã¨ã—ã¦é€ä¿¡ã—ã¦ãã ã•ã„ã€‚
 * @summary Install Library
 */
export const installLibraryInstallLibraryLibraryUuidPost = (
    libraryUuid: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.default.post(
      `http://localhost:50021/install_library/${libraryUuid}`,undefined,options
    );
  }



export const getInstallLibraryInstallLibraryLibraryUuidPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof installLibraryInstallLibraryLibraryUuidPost>>, TError,{libraryUuid: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof installLibraryInstallLibraryLibraryUuidPost>>, TError,{libraryUuid: string}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof installLibraryInstallLibraryLibraryUuidPost>>, {libraryUuid: string}> = (props) => {
          const {libraryUuid} = props ?? {};

          return  installLibraryInstallLibraryLibraryUuidPost(libraryUuid,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InstallLibraryInstallLibraryLibraryUuidPostMutationResult = NonNullable<Awaited<ReturnType<typeof installLibraryInstallLibraryLibraryUuidPost>>>
    
    export type InstallLibraryInstallLibraryLibraryUuidPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Install Library
 */
export const useInstallLibraryInstallLibraryLibraryUuidPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof installLibraryInstallLibraryLibraryUuidPost>>, TError,{libraryUuid: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof installLibraryInstallLibraryLibraryUuidPost>>,
        TError,
        {libraryUuid: string},
        TContext
      > => {

      const mutationOptions = getInstallLibraryInstallLibraryLibraryUuidPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * éŸ³å£°ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ã‚¢ãƒ³ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã—ã¾ã™ã€‚
 * @summary Uninstall Library
 */
export const uninstallLibraryUninstallLibraryLibraryUuidPost = (
    libraryUuid: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.default.post(
      `http://localhost:50021/uninstall_library/${libraryUuid}`,undefined,options
    );
  }



export const getUninstallLibraryUninstallLibraryLibraryUuidPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uninstallLibraryUninstallLibraryLibraryUuidPost>>, TError,{libraryUuid: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof uninstallLibraryUninstallLibraryLibraryUuidPost>>, TError,{libraryUuid: string}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof uninstallLibraryUninstallLibraryLibraryUuidPost>>, {libraryUuid: string}> = (props) => {
          const {libraryUuid} = props ?? {};

          return  uninstallLibraryUninstallLibraryLibraryUuidPost(libraryUuid,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UninstallLibraryUninstallLibraryLibraryUuidPostMutationResult = NonNullable<Awaited<ReturnType<typeof uninstallLibraryUninstallLibraryLibraryUuidPost>>>
    
    export type UninstallLibraryUninstallLibraryLibraryUuidPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Uninstall Library
 */
export const useUninstallLibraryUninstallLibraryLibraryUuidPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uninstallLibraryUninstallLibraryLibraryUuidPost>>, TError,{libraryUuid: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof uninstallLibraryUninstallLibraryLibraryUuidPost>>,
        TError,
        {libraryUuid: string},
        TContext
      > => {

      const mutationOptions = getUninstallLibraryUninstallLibraryLibraryUuidPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * æŒ‡å®šã•ã‚ŒãŸã‚¹ã‚¿ã‚¤ãƒ«ã‚’åˆæœŸåŒ–ã—ã¾ã™ã€‚
å®Ÿè¡Œã—ãªãã¦ã‚‚ä»–ã®APIã¯ä½¿ç”¨ã§ãã¾ã™ãŒã€åˆå›å®Ÿè¡Œæ™‚ã«æ™‚é–“ãŒã‹ã‹ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚
 * @summary Initialize Speaker
 */
export const initializeSpeakerInitializeSpeakerPost = (
    params: InitializeSpeakerInitializeSpeakerPostParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.default.post(
      `http://localhost:50021/initialize_speaker`,undefined,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getInitializeSpeakerInitializeSpeakerPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof initializeSpeakerInitializeSpeakerPost>>, TError,{params: InitializeSpeakerInitializeSpeakerPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof initializeSpeakerInitializeSpeakerPost>>, TError,{params: InitializeSpeakerInitializeSpeakerPostParams}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof initializeSpeakerInitializeSpeakerPost>>, {params: InitializeSpeakerInitializeSpeakerPostParams}> = (props) => {
          const {params} = props ?? {};

          return  initializeSpeakerInitializeSpeakerPost(params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type InitializeSpeakerInitializeSpeakerPostMutationResult = NonNullable<Awaited<ReturnType<typeof initializeSpeakerInitializeSpeakerPost>>>
    
    export type InitializeSpeakerInitializeSpeakerPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Initialize Speaker
 */
export const useInitializeSpeakerInitializeSpeakerPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof initializeSpeakerInitializeSpeakerPost>>, TError,{params: InitializeSpeakerInitializeSpeakerPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof initializeSpeakerInitializeSpeakerPost>>,
        TError,
        {params: InitializeSpeakerInitializeSpeakerPostParams},
        TContext
      > => {

      const mutationOptions = getInitializeSpeakerInitializeSpeakerPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * æŒ‡å®šã•ã‚ŒãŸã‚¹ã‚¿ã‚¤ãƒ«ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’è¿”ã—ã¾ã™ã€‚
 * @summary Is Initialized Speaker
 */
export const isInitializedSpeakerIsInitializedSpeakerGet = (
    params: IsInitializedSpeakerIsInitializedSpeakerGetParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<boolean>> => {
    
    return axios.default.get(
      `http://localhost:50021/is_initialized_speaker`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getIsInitializedSpeakerIsInitializedSpeakerGetQueryKey = (params: IsInitializedSpeakerIsInitializedSpeakerGetParams,) => {
    return [`http://localhost:50021/is_initialized_speaker`, ...(params ? [params]: [])] as const;
    }

    
export const getIsInitializedSpeakerIsInitializedSpeakerGetQueryOptions = <TData = Awaited<ReturnType<typeof isInitializedSpeakerIsInitializedSpeakerGet>>, TError = AxiosError<HTTPValidationError>>(params: IsInitializedSpeakerIsInitializedSpeakerGetParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof isInitializedSpeakerIsInitializedSpeakerGet>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getIsInitializedSpeakerIsInitializedSpeakerGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof isInitializedSpeakerIsInitializedSpeakerGet>>> = ({ signal }) => isInitializedSpeakerIsInitializedSpeakerGet(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof isInitializedSpeakerIsInitializedSpeakerGet>>, TError, TData> & { queryKey: QueryKey }
}

export type IsInitializedSpeakerIsInitializedSpeakerGetQueryResult = NonNullable<Awaited<ReturnType<typeof isInitializedSpeakerIsInitializedSpeakerGet>>>
export type IsInitializedSpeakerIsInitializedSpeakerGetQueryError = AxiosError<HTTPValidationError>

/**
 * @summary Is Initialized Speaker
 */
export const useIsInitializedSpeakerIsInitializedSpeakerGet = <TData = Awaited<ReturnType<typeof isInitializedSpeakerIsInitializedSpeakerGet>>, TError = AxiosError<HTTPValidationError>>(
 params: IsInitializedSpeakerIsInitializedSpeakerGetParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof isInitializedSpeakerIsInitializedSpeakerGet>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getIsInitializedSpeakerIsInitializedSpeakerGetQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ãƒ¦ãƒ¼ã‚¶ãƒ¼è¾æ›¸ã«ç™»éŒ²ã•ã‚Œã¦ã„ã‚‹å˜èªã®ä¸€è¦§ã‚’è¿”ã—ã¾ã™ã€‚
å˜èªã®è¡¨å±¤å½¢(surface)ã¯æ­£è¦åŒ–æ¸ˆã¿ã®ç‰©ã‚’è¿”ã—ã¾ã™ã€‚
 * @summary Get User Dict Words
 */
export const getUserDictWordsUserDictGet = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetUserDictWordsUserDictGet200>> => {
    
    return axios.default.get(
      `http://localhost:50021/user_dict`,options
    );
  }


export const getGetUserDictWordsUserDictGetQueryKey = () => {
    return [`http://localhost:50021/user_dict`] as const;
    }

    
export const getGetUserDictWordsUserDictGetQueryOptions = <TData = Awaited<ReturnType<typeof getUserDictWordsUserDictGet>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUserDictWordsUserDictGet>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserDictWordsUserDictGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserDictWordsUserDictGet>>> = ({ signal }) => getUserDictWordsUserDictGet({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserDictWordsUserDictGet>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserDictWordsUserDictGetQueryResult = NonNullable<Awaited<ReturnType<typeof getUserDictWordsUserDictGet>>>
export type GetUserDictWordsUserDictGetQueryError = AxiosError<unknown>

/**
 * @summary Get User Dict Words
 */
export const useGetUserDictWordsUserDictGet = <TData = Awaited<ReturnType<typeof getUserDictWordsUserDictGet>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUserDictWordsUserDictGet>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUserDictWordsUserDictGetQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ãƒ¦ãƒ¼ã‚¶ãƒ¼è¾æ›¸ã«è¨€è‘‰ã‚’è¿½åŠ ã—ã¾ã™ã€‚
 * @summary Add User Dict Word
 */
export const addUserDictWordUserDictWordPost = (
    params: AddUserDictWordUserDictWordPostParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    
    return axios.default.post(
      `http://localhost:50021/user_dict_word`,undefined,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getAddUserDictWordUserDictWordPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addUserDictWordUserDictWordPost>>, TError,{params: AddUserDictWordUserDictWordPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof addUserDictWordUserDictWordPost>>, TError,{params: AddUserDictWordUserDictWordPostParams}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addUserDictWordUserDictWordPost>>, {params: AddUserDictWordUserDictWordPostParams}> = (props) => {
          const {params} = props ?? {};

          return  addUserDictWordUserDictWordPost(params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddUserDictWordUserDictWordPostMutationResult = NonNullable<Awaited<ReturnType<typeof addUserDictWordUserDictWordPost>>>
    
    export type AddUserDictWordUserDictWordPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Add User Dict Word
 */
export const useAddUserDictWordUserDictWordPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addUserDictWordUserDictWordPost>>, TError,{params: AddUserDictWordUserDictWordPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof addUserDictWordUserDictWordPost>>,
        TError,
        {params: AddUserDictWordUserDictWordPostParams},
        TContext
      > => {

      const mutationOptions = getAddUserDictWordUserDictWordPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * ãƒ¦ãƒ¼ã‚¶ãƒ¼è¾æ›¸ã«ç™»éŒ²ã•ã‚Œã¦ã„ã‚‹è¨€è‘‰ã‚’æ›´æ–°ã—ã¾ã™ã€‚
 * @summary Rewrite User Dict Word
 */
export const rewriteUserDictWordUserDictWordWordUuidPut = (
    wordUuid: string,
    params: RewriteUserDictWordUserDictWordWordUuidPutParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.default.put(
      `http://localhost:50021/user_dict_word/${wordUuid}`,undefined,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getRewriteUserDictWordUserDictWordWordUuidPutMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof rewriteUserDictWordUserDictWordWordUuidPut>>, TError,{wordUuid: string;params: RewriteUserDictWordUserDictWordWordUuidPutParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof rewriteUserDictWordUserDictWordWordUuidPut>>, TError,{wordUuid: string;params: RewriteUserDictWordUserDictWordWordUuidPutParams}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof rewriteUserDictWordUserDictWordWordUuidPut>>, {wordUuid: string;params: RewriteUserDictWordUserDictWordWordUuidPutParams}> = (props) => {
          const {wordUuid,params} = props ?? {};

          return  rewriteUserDictWordUserDictWordWordUuidPut(wordUuid,params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RewriteUserDictWordUserDictWordWordUuidPutMutationResult = NonNullable<Awaited<ReturnType<typeof rewriteUserDictWordUserDictWordWordUuidPut>>>
    
    export type RewriteUserDictWordUserDictWordWordUuidPutMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Rewrite User Dict Word
 */
export const useRewriteUserDictWordUserDictWordWordUuidPut = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof rewriteUserDictWordUserDictWordWordUuidPut>>, TError,{wordUuid: string;params: RewriteUserDictWordUserDictWordWordUuidPutParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof rewriteUserDictWordUserDictWordWordUuidPut>>,
        TError,
        {wordUuid: string;params: RewriteUserDictWordUserDictWordWordUuidPutParams},
        TContext
      > => {

      const mutationOptions = getRewriteUserDictWordUserDictWordWordUuidPutMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * ãƒ¦ãƒ¼ã‚¶ãƒ¼è¾æ›¸ã«ç™»éŒ²ã•ã‚Œã¦ã„ã‚‹è¨€è‘‰ã‚’å‰Šé™¤ã—ã¾ã™ã€‚
 * @summary Delete User Dict Word
 */
export const deleteUserDictWordUserDictWordWordUuidDelete = (
    wordUuid: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.default.delete(
      `http://localhost:50021/user_dict_word/${wordUuid}`,options
    );
  }



export const getDeleteUserDictWordUserDictWordWordUuidDeleteMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUserDictWordUserDictWordWordUuidDelete>>, TError,{wordUuid: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteUserDictWordUserDictWordWordUuidDelete>>, TError,{wordUuid: string}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUserDictWordUserDictWordWordUuidDelete>>, {wordUuid: string}> = (props) => {
          const {wordUuid} = props ?? {};

          return  deleteUserDictWordUserDictWordWordUuidDelete(wordUuid,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteUserDictWordUserDictWordWordUuidDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUserDictWordUserDictWordWordUuidDelete>>>
    
    export type DeleteUserDictWordUserDictWordWordUuidDeleteMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Delete User Dict Word
 */
export const useDeleteUserDictWordUserDictWordWordUuidDelete = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUserDictWordUserDictWordWordUuidDelete>>, TError,{wordUuid: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteUserDictWordUserDictWordWordUuidDelete>>,
        TError,
        {wordUuid: string},
        TContext
      > => {

      const mutationOptions = getDeleteUserDictWordUserDictWordWordUuidDeleteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * ä»–ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼è¾æ›¸ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã™ã€‚
 * @summary Import User Dict Words
 */
export const importUserDictWordsImportUserDictPost = (
    importUserDictWordsImportUserDictPostBody: ImportUserDictWordsImportUserDictPostBody,
    params: ImportUserDictWordsImportUserDictPostParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.default.post(
      `http://localhost:50021/import_user_dict`,
      importUserDictWordsImportUserDictPostBody,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getImportUserDictWordsImportUserDictPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof importUserDictWordsImportUserDictPost>>, TError,{data: ImportUserDictWordsImportUserDictPostBody;params: ImportUserDictWordsImportUserDictPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof importUserDictWordsImportUserDictPost>>, TError,{data: ImportUserDictWordsImportUserDictPostBody;params: ImportUserDictWordsImportUserDictPostParams}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof importUserDictWordsImportUserDictPost>>, {data: ImportUserDictWordsImportUserDictPostBody;params: ImportUserDictWordsImportUserDictPostParams}> = (props) => {
          const {data,params} = props ?? {};

          return  importUserDictWordsImportUserDictPost(data,params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ImportUserDictWordsImportUserDictPostMutationResult = NonNullable<Awaited<ReturnType<typeof importUserDictWordsImportUserDictPost>>>
    export type ImportUserDictWordsImportUserDictPostMutationBody = ImportUserDictWordsImportUserDictPostBody
    export type ImportUserDictWordsImportUserDictPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Import User Dict Words
 */
export const useImportUserDictWordsImportUserDictPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof importUserDictWordsImportUserDictPost>>, TError,{data: ImportUserDictWordsImportUserDictPostBody;params: ImportUserDictWordsImportUserDictPostParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof importUserDictWordsImportUserDictPost>>,
        TError,
        {data: ImportUserDictWordsImportUserDictPostBody;params: ImportUserDictWordsImportUserDictPostParams},
        TContext
      > => {

      const mutationOptions = getImportUserDictWordsImportUserDictPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Supported Devices
 */
export const supportedDevicesSupportedDevicesGet = (
    params?: SupportedDevicesSupportedDevicesGetParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SupportedDevicesInfo>> => {
    
    return axios.default.get(
      `http://localhost:50021/supported_devices`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getSupportedDevicesSupportedDevicesGetQueryKey = (params?: SupportedDevicesSupportedDevicesGetParams,) => {
    return [`http://localhost:50021/supported_devices`, ...(params ? [params]: [])] as const;
    }

    
export const getSupportedDevicesSupportedDevicesGetQueryOptions = <TData = Awaited<ReturnType<typeof supportedDevicesSupportedDevicesGet>>, TError = AxiosError<HTTPValidationError>>(params?: SupportedDevicesSupportedDevicesGetParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof supportedDevicesSupportedDevicesGet>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSupportedDevicesSupportedDevicesGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof supportedDevicesSupportedDevicesGet>>> = ({ signal }) => supportedDevicesSupportedDevicesGet(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof supportedDevicesSupportedDevicesGet>>, TError, TData> & { queryKey: QueryKey }
}

export type SupportedDevicesSupportedDevicesGetQueryResult = NonNullable<Awaited<ReturnType<typeof supportedDevicesSupportedDevicesGet>>>
export type SupportedDevicesSupportedDevicesGetQueryError = AxiosError<HTTPValidationError>

/**
 * @summary Supported Devices
 */
export const useSupportedDevicesSupportedDevicesGet = <TData = Awaited<ReturnType<typeof supportedDevicesSupportedDevicesGet>>, TError = AxiosError<HTTPValidationError>>(
 params?: SupportedDevicesSupportedDevicesGetParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof supportedDevicesSupportedDevicesGet>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getSupportedDevicesSupportedDevicesGetQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Engine Manifest
 */
export const engineManifestEngineManifestGet = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<EngineManifest>> => {
    
    return axios.default.get(
      `http://localhost:50021/engine_manifest`,options
    );
  }


export const getEngineManifestEngineManifestGetQueryKey = () => {
    return [`http://localhost:50021/engine_manifest`] as const;
    }

    
export const getEngineManifestEngineManifestGetQueryOptions = <TData = Awaited<ReturnType<typeof engineManifestEngineManifestGet>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof engineManifestEngineManifestGet>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getEngineManifestEngineManifestGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof engineManifestEngineManifestGet>>> = ({ signal }) => engineManifestEngineManifestGet({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof engineManifestEngineManifestGet>>, TError, TData> & { queryKey: QueryKey }
}

export type EngineManifestEngineManifestGetQueryResult = NonNullable<Awaited<ReturnType<typeof engineManifestEngineManifestGet>>>
export type EngineManifestEngineManifestGetQueryError = AxiosError<unknown>

/**
 * @summary Engine Manifest
 */
export const useEngineManifestEngineManifestGet = <TData = Awaited<ReturnType<typeof engineManifestEngineManifestGet>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof engineManifestEngineManifestGet>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getEngineManifestEngineManifestGetQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * è¨­å®šãƒšãƒ¼ã‚¸ã‚’è¿”ã—ã¾ã™ã€‚
 * @summary Setting Get
 */
export const settingGetSettingGet = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.default.get(
      `http://localhost:50021/setting`,options
    );
  }


export const getSettingGetSettingGetQueryKey = () => {
    return [`http://localhost:50021/setting`] as const;
    }

    
export const getSettingGetSettingGetQueryOptions = <TData = Awaited<ReturnType<typeof settingGetSettingGet>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof settingGetSettingGet>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSettingGetSettingGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof settingGetSettingGet>>> = ({ signal }) => settingGetSettingGet({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof settingGetSettingGet>>, TError, TData> & { queryKey: QueryKey }
}

export type SettingGetSettingGetQueryResult = NonNullable<Awaited<ReturnType<typeof settingGetSettingGet>>>
export type SettingGetSettingGetQueryError = AxiosError<unknown>

/**
 * @summary Setting Get
 */
export const useSettingGetSettingGet = <TData = Awaited<ReturnType<typeof settingGetSettingGet>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof settingGetSettingGet>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getSettingGetSettingGetQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * è¨­å®šã‚’æ›´æ–°ã—ã¾ã™ã€‚
 * @summary Setting Post
 */
export const settingPostSettingPost = (
    bodySettingPostSettingPost: BodySettingPostSettingPost, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {const formUrlEncoded = new URLSearchParams();
formUrlEncoded.append('cors_policy_mode', bodySettingPostSettingPost.cors_policy_mode)
if(bodySettingPostSettingPost.allow_origin !== undefined) {
 formUrlEncoded.append('allow_origin', bodySettingPostSettingPost.allow_origin)
 }

    
    return axios.default.post(
      `http://localhost:50021/setting`,
      formUrlEncoded,options
    );
  }



export const getSettingPostSettingPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof settingPostSettingPost>>, TError,{data: BodySettingPostSettingPost}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof settingPostSettingPost>>, TError,{data: BodySettingPostSettingPost}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof settingPostSettingPost>>, {data: BodySettingPostSettingPost}> = (props) => {
          const {data} = props ?? {};

          return  settingPostSettingPost(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SettingPostSettingPostMutationResult = NonNullable<Awaited<ReturnType<typeof settingPostSettingPost>>>
    export type SettingPostSettingPostMutationBody = BodySettingPostSettingPost
    export type SettingPostSettingPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Setting Post
 */
export const useSettingPostSettingPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof settingPostSettingPost>>, TError,{data: BodySettingPostSettingPost}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof settingPostSettingPost>>,
        TError,
        {data: BodySettingPostSettingPost},
        TContext
      > => {

      const mutationOptions = getSettingPostSettingPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
